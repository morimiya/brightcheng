<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>阴影映射</title>
      <link href="/2019/03/10/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/"/>
      <url>/2019/03/10/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 阴影映射学习笔记</p><p><img src="/2019/03/10/阴影映射/result.png" alt=""></p></blockquote><a id="more"></a><ul><li>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系。场景和物体的深度感因此能够得到极大提升。</li></ul><h2 id="阴影映射-Shadow-Mapping"><a href="#阴影映射-Shadow-Mapping" class="headerlink" title="阴影映射(Shadow Mapping)"></a>阴影映射(Shadow Mapping)</h2><ul><li><p>在物理上，产生阴影的原因是由于发射至阴影处的光中途被其他物体截断了导致。从这种想法触发，对阴影映射的计算思路便顺势出来了。从光的位置及方向观测物体，所有看不见的部分都将被置于阴影中。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_theory.png" alt="阴影原理"></p></li><li><p>上图用来展示阴影映射的思路，蓝线部分表示会被光照射到，不会产生阴影，黑线部分光由于被挡住而无法到达，从而形成阴影。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_theory_spaces.png" alt=""></p></li><li>在绘制物体的时候，想要知道其上某一像素点是否在阴影当中，我们需要知道其是否有被什么东西遮挡住，是否是与光源连线中离光源最近的点。因此，我们较容易想到的方式便是，在判断某点A是否处于阴影中时，将观测点转移至光源所在点处来观测该点A，若从该视角下看不到点A，则表示点A在阴影之中。而要判断在某视角下某点是否能被看到，即为判断是否能被渲染，即为判断其能否通过深度测试。</li><li>因此，我们只需要生成一张存储着从光源视角所获得的各个点的最大深度值的纹理，便能判断一个点是否能在该视角下通过深度测试，从而获知其是否在阴影之中。</li><li>如上图，观测点P，在经过视角变换（乘以变换矩阵T）之后，获得其z值为0.9，而在光源视角下对应点的最大深度值为0.4，故点P不能通过深度测试，故其在阴影之中。</li></ul><h2 id="深度贴图-Depth-Map"><a href="#深度贴图-Depth-Map" class="headerlink" title="深度贴图(Depth Map)"></a>深度贴图(Depth Map)</h2><ul><li>我们管储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，我们将再次需要帧缓冲。</li></ul><h3 id="生成深度贴图"><a href="#生成深度贴图" class="headerlink" title="生成深度贴图"></a>生成深度贴图</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">GLuint depthMapFBO;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;depthMapFBO);<br><br><span class="hljs-comment">// 深度贴图的解析度</span><br><span class="hljs-keyword">const</span> GLuint SHADOW_WIDTH = <span class="hljs-number">1024</span>, SHADOW_HEIGHT = <span class="hljs-number">1024</span>;<br><br>GLuint depthMap;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;depthMap);<br>glBindTexture(GL_TEXTURE_2D, depthMap);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT,<br>             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br><br>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。</span><br><span class="hljs-comment">// 我们通过将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE,</span><br><span class="hljs-comment">// 来显式告诉OpenGL我们不适用任何颜色数据进行渲染。</span><br>glDrawBuffer(GL_NONE);<br>glReadBuffer(GL_NONE);<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br>...<br><span class="hljs-comment">// 1. 首选渲染深度贴图</span><br><span class="hljs-comment">// 因为阴影贴图经常和我们原来渲染的场景（通常是窗口解析度）有着不同的解析度，</span><br><span class="hljs-comment">// 我们需要改变视口（viewport）的参数以适应阴影贴图的尺寸。</span><br><span class="hljs-comment">// 如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</span><br>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);<br>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);<br>    glClear(GL_DEPTH_BUFFER_BIT);<br>    ConfigureShaderAndMatrices();<br>    RenderScene();<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 2. 像往常一样渲染场景，但这次使用深度贴图</span><br>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT);<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>ConfigureShaderAndMatrices();<br>glBindTexture(GL_TEXTURE_2D, depthMap);<br>RenderScene();<br></code></pre></td></tr></table></figure><h3 id="光源空间的变换"><a href="#光源空间的变换" class="headerlink" title="光源空间的变换"></a>光源空间的变换</h3><ul><li>如之前所说，我们需要对观测点变换至从光源视角下来观测，这种变换叫做光源空间的变换。</li><li>想进行光源空间变换，我们需要知道光源空间的投影和视图矩阵，然后通过变换矩阵乘以观测点，将观测点转换至光源空间。</li><li>这里使用平行光为光源，所以投影矩阵是正交投影矩阵。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">GLfloat near_plane = <span class="hljs-number">1.0f</span>, far_plane = <span class="hljs-number">7.5f</span>;<br>glm::mat4 lightProjection = glm::ortho(<span class="hljs-number">-10.0f</span>, <span class="hljs-number">10.0f</span>, <span class="hljs-number">-10.0f</span>, <span class="hljs-number">10.0f</span>, near_plane, far_plane);<br>glm::mat4 lightView = glm::lookAt(glm::vec(<span class="hljs-number">-2.0f</span>, <span class="hljs-number">4.0f</span>, <span class="hljs-number">-1.0f</span>), glm::vec3(<span class="hljs-number">0.0f</span>), glm::vec3(<span class="hljs-number">1.0</span>));<br>glm::mat4 lightSpaceMatrix = lightProjection * lightView;<br></code></pre></td></tr></table></figure><ul><li>这个lightSpaceMatrix正是前面我们称为T的那个变换矩阵。有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。</li></ul><h3 id="渲染至深度贴图"><a href="#渲染至深度贴图" class="headerlink" title="渲染至深度贴图"></a>渲染至深度贴图</h3><ul><li><img src="/2019/03/10/阴影映射/shadow_mapping_depth_map.png" alt="深度贴图"></li><li>对于深度贴图，只需要把顶点变换到光空间即可，故顶点着色器只需做空间变换即可。由于底层无论如何都会默认去设置深度缓冲，所以片段着色器不需要做什么额外操作。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vertex.vs</span><br><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> lightSpaceMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = lightSpaceMatrix * model * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1.0</span>f);<br>&#125;<br><br><span class="hljs-comment">// fragment.fs</span><br><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    <span class="hljs-comment">// gl_FragDepth = gl_FragCoord.z;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="渲染阴影"><a href="#渲染阴影" class="headerlink" title="渲染阴影"></a>渲染阴影</h2><ul><li><p>有了深度贴图后，我们就能在片段着色器中判断一个点是否在阴影之中了。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ShadowCalculation</span><span class="hljs-params">(vec4 fragPosLightSpace)</span><br></span>&#123;<br>    <span class="hljs-comment">// 执行透视除法</span><br>    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;<br>    <span class="hljs-comment">// 变换到[0,1]的范围</span><br>    projCoords = projCoords * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;<br>    <span class="hljs-comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span><br>    <span class="hljs-keyword">float</span> closestDepth = texture(shadowMap, projCoords.xy).r;<br>    <span class="hljs-comment">// 取得当前片元在光源视角下的深度</span><br>    <span class="hljs-keyword">float</span> currentDepth = projCoords.z;<br>    <span class="hljs-comment">// 检查当前片元是否在阴影中</span><br>    <span class="hljs-keyword">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>由于fragPosLightSpace不是由gl_Position传过来的，所以其并未有执行透视除法，所以需要手动对其执行透视除法。（虽然我们的例子是平截头体，w必然为1，但为了与锥视体统一代码，这里保留透视除法。）</p></li><li>projCoords目前属于NDC坐标，其取值范围为[-1, 1]，为了能从纹理从采样以及与采样结果中的z值进行比较，需要将其转换至[0, 1]范围中。</li><li>最后，我们对处于阴影中的像素点只保留环境光，去掉漫反射光和镜面反射光，得到效果如下图：</li><li><img src="/2019/03/10/阴影映射/render_shadow.png" alt="渲染阴影"></li></ul><h2 id="改进阴影贴图"><a href="#改进阴影贴图" class="headerlink" title="改进阴影贴图"></a>改进阴影贴图</h2><ul><li>渲染阴影中存在着大量肉眼可见且不可接受的问题，我们需要对其进行一定改进。</li></ul><h3 id="阴影失真-Shadow-Acne"><a href="#阴影失真-Shadow-Acne" class="headerlink" title="阴影失真(Shadow Acne)"></a>阴影失真(Shadow Acne)</h3><ul><li><p>渲染阴影图中明显交替出现的黑色阴影便是阴影失真。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_acne_diagram.png" alt="阴影失真成因"></p></li><li><p>图中蓝色线段表示在阴影贴图中的一个像素，由于解析度的问题，存在多个像素从阴影贴图中同一个点采样的情况。如在生成阴影贴图时，由于光源视角较高，导致较低视角下的两个像素点（A和B）在光源视角下只能保留一个（A），又由于视角与平面形成一定的角度，导致平面上每个点的z值不完全一样，于是深度贴图便只保留下了A点的z值。A点的z值相比B点的z值较小，在判断B点是否在阴影中时，在深度贴图中采样到的是A点的结果，由于z值比A点的大，故认为其处于阴影中。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_acne_bias.png" alt="阴影偏移"></p></li><li>针对阴影失真，可以使用阴影偏移（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片元就不会被错误地认为在表面之下了。</li><li>光照方向与表面法线夹角越大，偏移量越大。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> bias = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.05</span> * (<span class="hljs-number">1.0</span> - <span class="hljs-built_in">dot</span>(normal, lightDir)), <span class="hljs-number">0.005</span>);<br><span class="hljs-type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="悬浮-Peter-Panning"><a href="#悬浮-Peter-Panning" class="headerlink" title="悬浮(Peter Panning)"></a>悬浮(Peter Panning)</h3><ul><li>不懂，尚不理解，以及在贴地物体如果用正面剔除，悬浮更严重。用正面剔除能消除彼得潘问题尚未理解，实验结果也未能看出能消除。</li><li>在不添加阴影偏移时，阴影紧贴着物体。</li><li><p><img src="/2019/03/10/阴影映射/without_bias.png" alt="不添加阴影偏移"></p></li><li><p>添加了阴影偏移后，阴影相对物体出现了一定的位移，这是因为减去bias后，使得较小的currentDepth不再大于closestDepth，从而其被判断为非阴影，从而出现悬浮。</p></li><li><p><img src="/2019/03/10/阴影映射/peter_panning.png" alt="悬浮"></p></li><li><p>使用正面剔除后再来生成阴影贴图，发现箱子边缘出现非阴影带，这是因为剔除正面后，改用背面来生成阴影贴图，底部贴图由于太靠近场景面板，在减去bias后，不再认为其处于阴影之中，而两个背对光源的面的底下部分，也由于减去bias后，不再大于cloestDepth，从而造成非阴影带。</p></li><li><img src="/2019/03/10/阴影映射/front_cull.png" alt="使用正面剔除"></li></ul><h3 id="采样过多"><a href="#采样过多" class="headerlink" title="采样过多"></a>采样过多</h3><ul><li>光的视锥不可见的区域一律被认为是处于阴影中，不管它真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式为GL_REPEAT，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。即，同一个阴影会由于设置了纹理环绕方式，而多次出现。</li><li><p>对此，让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);<br>GLfloat borderColor[] = &#123; <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br>glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);<br></code></pre></td></tr></table></figure></li><li><p>当坐标超出了光的正交视锥的远平面。可以看到这片黑色区域总是出现在光源视锥的极远处。当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为我们把坐标的z元素和深度贴图的值进行了对比；它总是为大于1.0的z返回true。</p></li><li><p>如果投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> ShadowCalculation(<span class="hljs-type">vec4</span> fragPosLightSpace)<br>&#123;<br>    [...]<br>    <span class="hljs-keyword">if</span>(projCoords.z &gt; <span class="hljs-number">1.0</span>)<br>        shadow = <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/03/10/阴影映射/over_sampling_fixed.png" alt="修正过度采样"></p></li></ul><h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><ul><li>在上面的阴影结果中，我们都能很明显的看到锯齿边，这是因为深度贴图有一个固定的解析度，多个片元对应于一个纹理像素。结果就是多个片元会从深度贴图的同一个深度值进行采样，这几个片元便得到的是同一个阴影，这就会产生锯齿边。</li><li><p>采用类似于抗锯齿中多次采样的方式，一个简化版的PCF核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br><span class="hljs-comment">// 这个textureSize返回一个给定采样器纹理的0级mipmap的vec2类型的宽和高。</span><br><span class="hljs-comment">// 用1除以它返回一个单独纹理像素的大小</span><br><span class="hljs-type">vec2</span> texelSize = <span class="hljs-number">1.0</span> / <span class="hljs-built_in">textureSize</span>(shadowMap, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>; x &lt;= <span class="hljs-number">1</span>; ++x)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">-1</span>; y &lt;= <span class="hljs-number">1</span>; ++y)<br>    &#123;<br>        <span class="hljs-type">float</span> pcfDepth = <span class="hljs-built_in">texture</span>(shadowMap, projCoords.xy + <span class="hljs-type">vec2</span>(x, y) * texelSize).r;<br>        shadow += currentDepth - bias &gt; pcfDepth ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;        <br>    &#125;    <br>&#125;<br>shadow /= <span class="hljs-number">9.0</span>;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/03/10/阴影映射/pcf.png" alt="PCF"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 阴影映射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gamma校正</title>
      <link href="/2019/03/03/Gamma%E6%A0%A1%E6%AD%A3/"/>
      <url>/2019/03/03/Gamma%E6%A0%A1%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> Gamma校正学习笔记</p><p>Gamma校正</p></blockquote><a id="more"></a><h2 id="灰阶"><a href="#灰阶" class="headerlink" title="灰阶"></a>灰阶</h2><ul><li><img src="/2019/03/03/Gamma校正/gamma_correction_brightness.png" alt="灰阶图"></li><li>第一行是人眼所感知的正常灰阶图，第二行是根据如光子数量所展现出来的物理世界真实的灰阶图。</li><li>物理亮度和感知亮度的区别在于，物理亮度基于光子数量，感知亮度基于人的感觉，比如第二个灰阶里亮度0.1的光子数量是0.2的二分之一。</li><li><p>通过上图表明，人眼对亮度的感知并不是线性的。人眼对亮度的感知值约为真实亮度值的2次幂。</p></li><li><p><img src="/2019/03/03/Gamma校正/gamma_correction_gamma_curves.png" style="width: 400px;" alt="Gamma校正曲线"></p></li><li>CRT显示器亮度是电压的2.2次幂，与人眼的2次幂相当，因此物理亮度通过CRT显示器显示的效果与人眼相近，所以看起来效果是不错的。</li><li>需要注意的是，在屋里线性空间或CRT校正后的曲线空间中，亮度的最小值都是0，最大值都为1，仅是中间部分的亮度被压低，但也因人眼对低亮度更敏感，所以压低亮度刚好符合人眼感知灰度图。</li><li>由于此映射关系不是线性映射，在线性空间（gamma=1）中对亮度做倍数处理，其展现效果值并不是相同倍数（指数值结果上不同倍数，实际人眼感知上提高的是相同倍数），如在gamma=1的线性空间中对亮度0.5提高至1.0，其在gamma=2.2空间中的亮度变化则为0.218提高至1.0，约为4.5倍。</li></ul><h2 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h2><ul><li>上面提到，gamma=2.2刚好是符合人眼感知的，为何我们仍需要进行gamma校正？因为我们在程序中设置颜色、光照等都是基于线性空间（gammma=1）来设置的，我们希望最终颜色在显示器中输出的结果与线性空间中计算到的一致。</li><li>在将颜色显示到显示器之前，我们先对颜色应用Gamma校正曲线。线性的颜色显示在显示器上相当于降低了2.2次幂的亮度，所以Gamma校正便是对线性的颜色取1/2.2次幂。</li></ul><h3 id="OpenGL中使用Gamma校正"><a href="#OpenGL中使用Gamma校正" class="headerlink" title="OpenGL中使用Gamma校正"></a>OpenGL中使用Gamma校正</h3><h4 id="使用OpenGL内建的sRGB帧缓冲"><a href="#使用OpenGL内建的sRGB帧缓冲" class="headerlink" title="使用OpenGL内建的sRGB帧缓冲"></a>使用OpenGL内建的sRGB帧缓冲</h4><ul><li>开启GL_FRAMEBUFFER_SRGB，可以告诉OpenGL每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正sRGB颜色。sRGB这个颜色空间大致对应于gamma2.2，它也是家用设备的一个标准。开启GL_FRAMEBUFFER_SRGB以后，每次片段着色器运行后续帧缓冲，OpenGL将自动执行gamma校正，包括默认帧缓冲。</li><li><p>开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_FRAMEBUFFER_SRGB);<br></code></pre></td></tr></table></figure></li><li><p>我们只需要在最后一步进行gamma校正，如果在最后输出之前就进行gamma校正，所有的后续操作都是在操作不正确的颜色值。例如，如果你使用多个帧缓冲，你可能打算让两个帧缓冲之间传递的中间结果仍然保持线性空间颜色，只是给发送给显示器的最后的那个帧缓冲应用gamma校正。</p></li></ul><h4 id="在片段着色器最后应用gamma校正"><a href="#在片段着色器最后应用gamma校正" class="headerlink" title="在片段着色器最后应用gamma校正"></a>在片段着色器最后应用gamma校正</h4><ul><li><p>颜色在发送到帧缓冲前，其颜色就被校正了。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// do super fancy lighting</span><br>    [...]<br>    <span class="hljs-comment">// apply gamma correction</span><br>    <span class="hljs-type">float</span> gamma = <span class="hljs-number">2.2</span>;<br>    fragColor.rgb = <span class="hljs-built_in">pow</span>(fragColor.rgb, <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>/gamma));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>此方法繁琐的地方在于需要在每个片段着色器的最后都应用gamma校正。一个更简单的方案是在你的渲染循环中引入后处理阶段，在后处理四边形上应用gamma校正，这样你只要做一次就好了。</p></li></ul><h3 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h3><ul><li>由于我们绘制及编辑图像的时候是在应用了gamma校正的显示器中进行了，因此，制作出来的图像可以理解为已经进行过一次gamma校正了。对于这种图像纹理，如果我们再使用gamma校正，就相当于对其进行了两次gamma校正，其颜色结果整体上会偏亮很多。</li><li><img src="/2019/03/03/Gamma校正/gamma_correction_srgbtextures.png" alt="对sRGB纹理进行gamma校正对比"></li><li><p>OpenGL提供了GL_SRGB和GL_SRGB_ALPHA内部纹理格式，如果我们在OpenGL中创建了一个纹理，把它指定为以上两种sRGB纹理格式其中之一，OpenGL将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个sRGB纹理：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_SRGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);<br></code></pre></td></tr></table></figure></li><li><p>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。而为了获取光照参数的纹理，像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了。指定sRGB纹理时要当心。</p></li><li><p>直接对sRGB空间的颜色进行混合，会出现1+1&gt;2的效果，如下图中明显的相交光圈。将sRGB颜色映射回线性空间再进行混合，能得到合理的效果。这是因为，我们想要的是对输出的颜色值进行混合，而直接操作sRGB值相当于对输出的颜色值的自变量进行操作，而从自变量到输出颜色的过程并不是线性的，从而造成明显的光圈。即 $f=x^{2.2}$ ，sRGB即为x值，我们想要的是对f进行线性改变，因此对x做线性改变是不行的。</p></li><li><p><img src="/2019/03/03/Gamma校正/linearspot.jpg" style="width: 400px;" alt="sRGB空间颜色混合"></p></li><li><img src="/2019/03/03/Gamma校正/gammaspot.jpg" style="width: 400px;" alt="线性空间颜色混合"></li></ul><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><ul><li>此前，我们使用的光照衰减方程为：<script type="math/tex; mode=display">F_{att} = \frac{1.0}{K_{c} + K_{l} * d + K_{q} * d^2}</script></li><li>该方程给予我们调整距离常数与距离的平方的常数，给了我们很大的自由性。</li><li><p>真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> attenuation = <span class="hljs-number">1.0</span> / (distance * distance);<br></code></pre></td></tr></table></figure></li><li><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。改用双曲线函数却能取到较好的效果：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> attenuation = <span class="hljs-number">1.0</span> / distance;<br></code></pre></td></tr></table></figure></li><li><p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后双曲线衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。下图显示了其中的不同：</p></li><li><img src="/2019/03/03/Gamma校正/gamma_correction_attenuation.png" alt="衰减对比"></li><li><p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在显示器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成 $(1.0 / distance^2)^{2.2}$ 。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了 $(1.0 / distance)^{2.2} = 1.0 / distance^{2.2}$ 。这和物理公式是很相似的。</p></li><li><p>gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数的原因。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> Gamma校正 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DXT压缩纹理格式</title>
      <link href="/2019/02/24/DXT%E5%8E%8B%E7%BC%A9%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/02/24/DXT%E5%8E%8B%E7%BC%A9%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DXT1，DXT3和DXT5三种压缩纹理的内存格式及其计算RGB及alpha值的方式。<br><a id="more"></a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>DXT1，DXT3和DXT5三种压缩纹理格式均是将图片切割成4X4的小块(Block)做独立的压缩处理，这就要求图片的长和宽都必须是4的整数倍。这种压缩方式与传统基于图片整体信息进行压缩的方式（如jpg的哈夫曼压缩）相比，其压缩率会较低，但由于每个4X4的小块(Block)的压缩是独立进行的，其十分适合应用于显卡的并行运算。</li></ul><h2 id="DXT1"><a href="#DXT1" class="headerlink" title="DXT1"></a>DXT1</h2><ul><li><img src="/2019/02/24/DXT压缩纹理格式/dxt1_format.jpg" alt="DXT1纹理格式"></li><li>DXT1的每个4X4小块大小为64bits，其内存结构如上图所示。块的前32bits用来存储两个565格式的颜色，这里记为<font color="#D2691E" size="4"> <em>color_0</em> </font>和<font color="#D2691E" size="4"> <em>color_1</em> </font>，剩余32bits分成4X4个格子，每个格子占2bits，每个格子各自对应一个像素。</li><li><p>每个格子占2bits，可以表示4种状态，分别用RGB0，RGB1，RGB2，RGB3表示，每种状态下的颜色取值情况如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> color_0 &gt; color_1:<br>    <span class="hljs-number">1.</span> RGB0 = Color565toRGB(color_0)<br>    <span class="hljs-number">1.</span> RGB1 = Color565toRGB(color_1)<br>    <span class="hljs-number">1.</span> RGB2 = (<span class="hljs-number">2</span>*RGB0 + RGB1) / <span class="hljs-number">3</span><br>    <span class="hljs-number">1.</span> RGB3 = (RGB0 + <span class="hljs-number">2</span>*RGB1) / <span class="hljs-number">3</span><br><span class="hljs-number">2.</span> color_0 &lt;= color_1:<br>    <span class="hljs-number">1.</span> RGB0 = Color565toRGB(color_0)<br>    <span class="hljs-number">1.</span> RGB1 = Color565toRGB(color_1)<br>    <span class="hljs-number">1.</span> RGB2 = (RGB0 + RGB1) / <span class="hljs-number">2</span><br>    <span class="hljs-number">1.</span> RGB3 = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>除了RGB3 = (0, 0, 0, 0)的情况，其余情况的alpha值均为0xFF，即DXT1纹理格式对alpha通道的支持为要么全透，要么全不透，一个4X4的块中其最多表示4种不同颜色，存储2个565格式的颜色及通过线性插值获得另外2个颜色。</p></li><li><p>关于color_0和color_1的颜色是如何确定的，我没有细看生成的代码，做过一些简单测试，对于一个4X4仅含有(0,0,0,255), (1,0,0,255), (2,0,0,255), (3,0,0,255)四种颜色的bmp图，用Nvidia提供的Nvdxt工具转成的DXT1格式，发现里面只剩下三种颜色了。</p></li><li><p>DXT1块具体解析的代码如下：</p></li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// DXT1 block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockDXT1</span><br>&#123;</span><br>    Color16 col0;<br>    Color16 col1;<br>    <span class="hljs-keyword">union</span> &#123;<br>        uint8 row[<span class="hljs-number">4</span>];<br>        uint indices;<br>    &#125;;<br>&#125;;<br><br>uint BlockDXT1::evaluatePalette(Color32 color_array[<span class="hljs-number">4</span>], <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// Does bit expansion before interpolation.</span><br>    color_array[<span class="hljs-number">0</span>].b = (col0.b &lt;&lt; <span class="hljs-number">3</span>) | (col0.b &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">0</span>].g = (col0.g &lt;&lt; <span class="hljs-number">2</span>) | (col0.g &gt;&gt; <span class="hljs-number">4</span>);<br>    color_array[<span class="hljs-number">0</span>].r = (col0.r &lt;&lt; <span class="hljs-number">3</span>) | (col0.r &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">0</span>].a = <span class="hljs-number">0xFF</span>;<br><br>    color_array[<span class="hljs-number">1</span>].r = (col1.r &lt;&lt; <span class="hljs-number">3</span>) | (col1.r &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">1</span>].g = (col1.g &lt;&lt; <span class="hljs-number">2</span>) | (col1.g &gt;&gt; <span class="hljs-number">4</span>);<br>    color_array[<span class="hljs-number">1</span>].b = (col1.b &lt;&lt; <span class="hljs-number">3</span>) | (col1.b &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">1</span>].a = <span class="hljs-number">0xFF</span>;<br><br>    <span class="hljs-keyword">if</span>( col0.u &gt; col1.u ) &#123;<br>        <span class="hljs-keyword">int</span> bias = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (d3d9) bias = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Four-color block: derive the other two colors.</span><br>        color_array[<span class="hljs-number">2</span>].r = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">0</span>].r + color_array[<span class="hljs-number">1</span>].r + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">2</span>].g = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">0</span>].g + color_array[<span class="hljs-number">1</span>].g + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">2</span>].b = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">0</span>].b + color_array[<span class="hljs-number">1</span>].b + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">2</span>].a = <span class="hljs-number">0xFF</span>;<br><br>        color_array[<span class="hljs-number">3</span>].r = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">1</span>].r + color_array[<span class="hljs-number">0</span>].r + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">3</span>].g = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">1</span>].g + color_array[<span class="hljs-number">0</span>].g + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">3</span>].b = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">1</span>].b + color_array[<span class="hljs-number">0</span>].b + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">3</span>].a = <span class="hljs-number">0xFF</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Three-color block: derive the other color.</span><br>        color_array[<span class="hljs-number">2</span>].r = (color_array[<span class="hljs-number">0</span>].r + color_array[<span class="hljs-number">1</span>].r) / <span class="hljs-number">2</span>;<br>        color_array[<span class="hljs-number">2</span>].g = (color_array[<span class="hljs-number">0</span>].g + color_array[<span class="hljs-number">1</span>].g) / <span class="hljs-number">2</span>;<br>        color_array[<span class="hljs-number">2</span>].b = (color_array[<span class="hljs-number">0</span>].b + color_array[<span class="hljs-number">1</span>].b) / <span class="hljs-number">2</span>;<br>        color_array[<span class="hljs-number">2</span>].a = <span class="hljs-number">0xFF</span>;<br><br>        <span class="hljs-comment">// Set all components to 0 to match DXT specs.</span><br>        color_array[<span class="hljs-number">3</span>].r = <span class="hljs-number">0x00</span>; <span class="hljs-comment">// color_array[2].r;</span><br>        color_array[<span class="hljs-number">3</span>].g = <span class="hljs-number">0x00</span>; <span class="hljs-comment">// color_array[2].g;</span><br>        color_array[<span class="hljs-number">3</span>].b = <span class="hljs-number">0x00</span>; <span class="hljs-comment">// color_array[2].b;</span><br>        color_array[<span class="hljs-number">3</span>].a = <span class="hljs-number">0x00</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">void</span> BlockDXT1::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    nvDebugCheck(block != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Decode color block.</span><br>    Color32 color_array[<span class="hljs-number">4</span>];<br>    evaluatePalette(color_array, d3d9);<br><br>    <span class="hljs-comment">// Write color block.</span><br>    <span class="hljs-keyword">for</span>( uint j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++ ) &#123;<br>        <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ ) &#123;<br>            uint idx = (row[j] &gt;&gt; (<span class="hljs-number">2</span> * i)) &amp; <span class="hljs-number">3</span>;<br>            block-&gt;color(i, j) = color_array[idx];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="DXT3"><a href="#DXT3" class="headerlink" title="DXT3"></a>DXT3</h2><ul><li><img src="/2019/02/24/DXT压缩纹理格式/dxt3_alphablock_format.jpg" alt="DXT3Alpha块格式"></li><li>DXT3的每个4X4小块大小为128bits，前64bits用来存储alpha信息的Alpha块，其内存结构如上图所示。后64bits用来存储颜色信息，其内存结构及解析方式与DXT1完全一致。</li><li>DXT3的Alpha块大小为64bits，均等分成16个小格子，每个格子占4bits，各自对应一个像素的alpha数据。</li><li><p>每个格子占4bits，可以表示16种状态，因此，DXT3可以表示16种不同的硬编码alpha值，每种状态对应的alpha值计算方式如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> 设v为某个格子的具体状态值。<br><span class="hljs-number">2.</span> 该格子对应的alpha值则为：(v &lt;&lt; <span class="hljs-number">4</span>) | v 。<br><span class="hljs-number">3.</span> 例如格子(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)的二进制数据为<span class="hljs-number">0110</span>，则其状态值为<span class="hljs-number">6</span>。<br><span class="hljs-number">4.</span> 状态值对应的alpha值二进制格式为<span class="hljs-number">01100110</span>，转为十进制即为<span class="hljs-number">102</span>，即格子(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)的alpha值为<span class="hljs-number">102</span>。<br></code></pre></td></tr></table></figure></li><li><p>DXT3块具体解析的代码如下：</p></li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AlphaBlockDXT3</span><br>&#123;</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            uint alpha0 : <span class="hljs-number">4</span>;<br>            uint alpha1 : <span class="hljs-number">4</span>;<br>            uint alpha2 : <span class="hljs-number">4</span>;<br>            uint alpha3 : <span class="hljs-number">4</span>;<br>            uint alpha4 : <span class="hljs-number">4</span>;<br>            uint alpha5 : <span class="hljs-number">4</span>;<br>            uint alpha6 : <span class="hljs-number">4</span>;<br>            uint alpha7 : <span class="hljs-number">4</span>;<br>            uint alpha8 : <span class="hljs-number">4</span>;<br>            uint alpha9 : <span class="hljs-number">4</span>;<br>            uint alphaA : <span class="hljs-number">4</span>;<br>            uint alphaB : <span class="hljs-number">4</span>;<br>            uint alphaC : <span class="hljs-number">4</span>;<br>            uint alphaD : <span class="hljs-number">4</span>;<br>            uint alphaE : <span class="hljs-number">4</span>;<br>            uint alphaF : <span class="hljs-number">4</span>;<br>        &#125;;<br>        uint16 row[<span class="hljs-number">4</span>];<br>    &#125;;<br>&#125;;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT3::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    block-&gt;color(<span class="hljs-number">0x0</span>).a = (alpha0 &lt;&lt; <span class="hljs-number">4</span>) | alpha0;<br>    block-&gt;color(<span class="hljs-number">0x1</span>).a = (alpha1 &lt;&lt; <span class="hljs-number">4</span>) | alpha1;<br>    block-&gt;color(<span class="hljs-number">0x2</span>).a = (alpha2 &lt;&lt; <span class="hljs-number">4</span>) | alpha2;<br>    block-&gt;color(<span class="hljs-number">0x3</span>).a = (alpha3 &lt;&lt; <span class="hljs-number">4</span>) | alpha3;<br>    block-&gt;color(<span class="hljs-number">0x4</span>).a = (alpha4 &lt;&lt; <span class="hljs-number">4</span>) | alpha4;<br>    block-&gt;color(<span class="hljs-number">0x5</span>).a = (alpha5 &lt;&lt; <span class="hljs-number">4</span>) | alpha5;<br>    block-&gt;color(<span class="hljs-number">0x6</span>).a = (alpha6 &lt;&lt; <span class="hljs-number">4</span>) | alpha6;<br>    block-&gt;color(<span class="hljs-number">0x7</span>).a = (alpha7 &lt;&lt; <span class="hljs-number">4</span>) | alpha7;<br>    block-&gt;color(<span class="hljs-number">0x8</span>).a = (alpha8 &lt;&lt; <span class="hljs-number">4</span>) | alpha8;<br>    block-&gt;color(<span class="hljs-number">0x9</span>).a = (alpha9 &lt;&lt; <span class="hljs-number">4</span>) | alpha9;<br>    block-&gt;color(<span class="hljs-number">0xA</span>).a = (alphaA &lt;&lt; <span class="hljs-number">4</span>) | alphaA;<br>    block-&gt;color(<span class="hljs-number">0xB</span>).a = (alphaB &lt;&lt; <span class="hljs-number">4</span>) | alphaB;<br>    block-&gt;color(<span class="hljs-number">0xC</span>).a = (alphaC &lt;&lt; <span class="hljs-number">4</span>) | alphaC;<br>    block-&gt;color(<span class="hljs-number">0xD</span>).a = (alphaD &lt;&lt; <span class="hljs-number">4</span>) | alphaD;<br>    block-&gt;color(<span class="hljs-number">0xE</span>).a = (alphaE &lt;&lt; <span class="hljs-number">4</span>) | alphaE;<br>    block-&gt;color(<span class="hljs-number">0xF</span>).a = (alphaF &lt;&lt; <span class="hljs-number">4</span>) | alphaF;<br>&#125;<br><br><span class="hljs-comment">/// DXT3 block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockDXT3</span><br>&#123;</span><br>    AlphaBlockDXT3 alpha;<br>    BlockDXT1 color;<br>&#125;;<br><br><span class="hljs-keyword">void</span> BlockDXT3::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// Decode color.</span><br>    color.decodeBlock(block, d3d9);<br><br>    <span class="hljs-comment">// Decode alpha.</span><br>    alpha.decodeBlock(block, d3d9);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="DXT5"><a href="#DXT5" class="headerlink" title="DXT5"></a>DXT5</h2><ul><li><img src="/2019/02/24/DXT压缩纹理格式/dxt5_alphablock_format.jpg" alt="DXT5Alpha块格式"></li><li>DXT5的每个4X4小块大小为128bits，前64bits用来存储alpha信息的Alpha块，其内存结构如上图所示。后64bits用来存储颜色信息，其内存结构及解析方式与DXT1完全一致。</li><li>DXT5的Alpha块大小为64bits，块的前16bits用来存储两个alpha值，这里记为<font color="#D2691E" size="4"> <em>alpha_0</em> </font>和<font color="#D2691E" size="4"> <em>alpha_1</em> </font>，剩余48bits分成4X4个格子，每个格子占3bits，每个格子各自对应一个像素。</li><li><p>每个格子占3bits，可以表示8种状态，分别用Alpha0 - Alpha7表示，每种状态下的alpha取值情况如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> alpha_0 &gt; alpha_1:<br>    <span class="hljs-number">0.</span> Alpha0 = alpha_0<br>    <span class="hljs-number">1.</span> Alpha1 = alpha_1<br>    <span class="hljs-number">2.</span> Alpha2 = (<span class="hljs-number">6</span> * Alpha0 + <span class="hljs-number">1</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">3.</span> Alpha3 = (<span class="hljs-number">5</span> * Alpha0 + <span class="hljs-number">2</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">4.</span> Alpha4 = (<span class="hljs-number">4</span> * Alpha0 + <span class="hljs-number">3</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">5.</span> Alpha5 = (<span class="hljs-number">3</span> * Alpha0 + <span class="hljs-number">4</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">6.</span> Alpha6 = (<span class="hljs-number">2</span> * Alpha0 + <span class="hljs-number">5</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">7.</span> Alpha7 = (<span class="hljs-number">1</span> * Alpha0 + <span class="hljs-number">6</span> * Alpha1) / <span class="hljs-number">7</span><br><span class="hljs-number">2.</span> alpha_0 &lt;= alpha_1:<br>    <span class="hljs-number">0.</span> Alpha0 = alpha_0<br>    <span class="hljs-number">1.</span> Alpha1 = alpha_1<br>    <span class="hljs-number">2.</span> Alpha2 = (<span class="hljs-number">4</span> * Alpha0 + <span class="hljs-number">1</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">3.</span> Alpha3 = (<span class="hljs-number">3</span> * Alpha0 + <span class="hljs-number">2</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">4.</span> Alpha4 = (<span class="hljs-number">2</span> * Alpha0 + <span class="hljs-number">3</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">5.</span> Alpha5 = (<span class="hljs-number">1</span> * Alpha0 + <span class="hljs-number">4</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">6.</span> Alpha6 = <span class="hljs-number">0x00</span><br>    <span class="hljs-number">7.</span> Alpha7 = <span class="hljs-number">0xFF</span><br></code></pre></td></tr></table></figure></li><li><p>上面情况简言之，便是：</p><ul><li>对于<font color="#D2691E" size="4"> <em>alpha_0</em> &gt; <em>alpha_1</em> </font>的情况，Alpha0 = <font color="#D2691E" size="4"> <em>alpha_0</em> </font>，Alpha1 = <font color="#D2691E" size="4"> <em>alpha_1</em> </font>，余下6种颜色为Alpha0和Alpha1的线性插值结果。</li><li>对于<font color="#D2691E" size="4"> <em>alpha_0</em> &lt;= <em>alpha_1</em> </font>的情况，Alpha0 = <font color="#D2691E" size="4"> <em>alpha_0</em> </font>，Alpha1 = <font color="#D2691E" size="4"> <em>alpha_1</em> </font>，Alpha6=0x00，Alpha7=0xFF，余下4种颜色为Alpha0和Alpha1的线性插值结果。</li></ul></li><li><p>DXT5块具体解析的代码如下：</p></li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// DXT5 alpha block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AlphaBlockDXT5</span><br>&#123;</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            uint64 alpha0 : <span class="hljs-number">8</span>;<span class="hljs-comment">// 8</span><br>            uint64 alpha1 : <span class="hljs-number">8</span>;<span class="hljs-comment">// 16</span><br>            uint64 bits0 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 3 - 19</span><br>            uint64 bits1 : <span class="hljs-number">3</span>; <span class="hljs-comment">// 6 - 22</span><br>            uint64 bits2 : <span class="hljs-number">3</span>; <span class="hljs-comment">// 9 - 25</span><br>            uint64 bits3 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 12 - 28</span><br>            uint64 bits4 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 15 - 31</span><br>            uint64 bits5 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 18 - 34</span><br>            uint64 bits6 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 21 - 37</span><br>            uint64 bits7 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 24 - 40</span><br>            uint64 bits8 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 27 - 43</span><br>            uint64 bits9 : <span class="hljs-number">3</span>; <span class="hljs-comment">// 30 - 46</span><br>            uint64 bitsA : <span class="hljs-number">3</span>; <span class="hljs-comment">// 33 - 49</span><br>            uint64 bitsB : <span class="hljs-number">3</span>;<span class="hljs-comment">// 36 - 52</span><br>            uint64 bitsC : <span class="hljs-number">3</span>;<span class="hljs-comment">// 39 - 55</span><br>            uint64 bitsD : <span class="hljs-number">3</span>;<span class="hljs-comment">// 42 - 58</span><br>            uint64 bitsE : <span class="hljs-number">3</span>;<span class="hljs-comment">// 45 - 61</span><br>            uint64 bitsF : <span class="hljs-number">3</span>;<span class="hljs-comment">// 48 - 64</span><br>        &#125;;<br>        uint64 u;<br>    &#125;;<br>&#125;;<br>``<br><span class="hljs-comment">/// DXT5 block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockDXT5</span><br>&#123;</span><br>    AlphaBlockDXT5 alpha;<br>    BlockDXT1 color;<br>&#125;;<br>``<br><br><span class="hljs-comment">/*----------------------------------------------------------------------------<br>BlockDXT5<br>----------------------------------------------------------------------------*/</span><br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::evaluatePalette(uint8 alpha[<span class="hljs-number">8</span>], <span class="hljs-keyword">bool</span> d3d9) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (alpha0 &gt; alpha1) &#123;<br>        evaluatePalette8(alpha, d3d9);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        evaluatePalette6(alpha, d3d9);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::evaluatePalette8(uint8 alpha[<span class="hljs-number">8</span>], <span class="hljs-keyword">bool</span> d3d9) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">int</span> bias = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (d3d9) bias = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 8-alpha block:  derive the other six alphas.</span><br>    <span class="hljs-comment">// Bit code 000 = alpha0, 001 = alpha1, others are interpolated.</span><br>    alpha[<span class="hljs-number">0</span>] = alpha0;<br>    alpha[<span class="hljs-number">1</span>] = alpha1;<br>    alpha[<span class="hljs-number">2</span>] = (<span class="hljs-number">6</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 010</span><br>    alpha[<span class="hljs-number">3</span>] = (<span class="hljs-number">5</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 011</span><br>    alpha[<span class="hljs-number">4</span>] = (<span class="hljs-number">4</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">3</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 100</span><br>    alpha[<span class="hljs-number">5</span>] = (<span class="hljs-number">3</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">4</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 101</span><br>    alpha[<span class="hljs-number">6</span>] = (<span class="hljs-number">2</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">5</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 110</span><br>    alpha[<span class="hljs-number">7</span>] = (<span class="hljs-number">1</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">6</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 111</span><br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::evaluatePalette6(uint8 alpha[<span class="hljs-number">8</span>], <span class="hljs-keyword">bool</span> d3d9) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">int</span> bias = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (d3d9) bias = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 6-alpha block.</span><br>    <span class="hljs-comment">// Bit code 000 = alpha0, 001 = alpha1, others are interpolated.</span><br>    alpha[<span class="hljs-number">0</span>] = alpha0;<br>    alpha[<span class="hljs-number">1</span>] = alpha1;<br>    alpha[<span class="hljs-number">2</span>] = (<span class="hljs-number">4</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 010</span><br>    alpha[<span class="hljs-number">3</span>] = (<span class="hljs-number">3</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 011</span><br>    alpha[<span class="hljs-number">4</span>] = (<span class="hljs-number">2</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">3</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 100</span><br>    alpha[<span class="hljs-number">5</span>] = (<span class="hljs-number">1</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">4</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 101</span><br>    alpha[<span class="hljs-number">6</span>] = <span class="hljs-number">0x00</span>;                                        <span class="hljs-comment">// Bit code 110</span><br>    alpha[<span class="hljs-number">7</span>] = <span class="hljs-number">0xFF</span>;                                        <span class="hljs-comment">// Bit code 111</span><br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::indices(uint8 index_array[<span class="hljs-number">16</span>]) <span class="hljs-keyword">const</span><br>&#123;<br>    index_array[<span class="hljs-number">0x0</span>] = bits0;<br>    index_array[<span class="hljs-number">0x1</span>] = bits1;<br>    index_array[<span class="hljs-number">0x2</span>] = bits2;<br>    index_array[<span class="hljs-number">0x3</span>] = bits3;<br>    index_array[<span class="hljs-number">0x4</span>] = bits4;<br>    index_array[<span class="hljs-number">0x5</span>] = bits5;<br>    index_array[<span class="hljs-number">0x6</span>] = bits6;<br>    index_array[<span class="hljs-number">0x7</span>] = bits7;<br>    index_array[<span class="hljs-number">0x8</span>] = bits8;<br>    index_array[<span class="hljs-number">0x9</span>] = bits9;<br>    index_array[<span class="hljs-number">0xA</span>] = bitsA;<br>    index_array[<span class="hljs-number">0xB</span>] = bitsB;<br>    index_array[<span class="hljs-number">0xC</span>] = bitsC;<br>    index_array[<span class="hljs-number">0xD</span>] = bitsD;<br>    index_array[<span class="hljs-number">0xE</span>] = bitsE;<br>    index_array[<span class="hljs-number">0xF</span>] = bitsF;<br>&#125;<br><br>uint AlphaBlockDXT5::index(uint index) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">int</span> offset = (<span class="hljs-number">3</span> * index + <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> uint((<span class="hljs-keyword">this</span>-&gt;u &gt;&gt; offset) &amp; <span class="hljs-number">0x7</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::setIndex(uint index, uint value)<br>&#123;<br>    <span class="hljs-keyword">int</span> offset = (<span class="hljs-number">3</span> * index + <span class="hljs-number">16</span>);<br>    uint64 mask = uint64(<span class="hljs-number">0x7</span>) &lt;&lt; offset;<br>    <span class="hljs-keyword">this</span>-&gt;u = (<span class="hljs-keyword">this</span>-&gt;u &amp; ~mask) | (uint64(value) &lt;&lt; offset);<br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    uint8 alpha_array[<span class="hljs-number">8</span>];<br>    evaluatePalette(alpha_array, d3d9);<br><br>    uint8 index_array[<span class="hljs-number">16</span>];<br>    indices(index_array);<br><br>    <span class="hljs-keyword">for</span>(uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        block-&gt;color(i).a = alpha_array[index_array[i]];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> BlockDXT5::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// Decode color.</span><br>    color.decodeBlock(block, d3d9);<br><br>    <span class="hljs-comment">// Decode alpha.</span><br>    alpha.decodeBlock(block, d3d9);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>转载请注明出处：<a href="http://morimiya.me/" target="_blank" rel="noopener">morimiya.me</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> DXT压缩纹理格式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DXT </tag>
            
            <tag> 压缩纹理 </tag>
            
            <tag> S3TC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Blinn-Phong光照</title>
      <link href="/2019/02/24/Blinn-Phong%E5%85%89%E7%85%A7/"/>
      <url>/2019/02/24/Blinn-Phong%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级光照学习笔记</p><p>Blinn-Phong光照</p></blockquote><a id="more"></a><h2 id="复习冯氏光照模型"><a href="#复习冯氏光照模型" class="headerlink" title="复习冯氏光照模型"></a>复习冯氏光照模型</h2><ul><li>在冯氏光照模型中，物体的光由环境光(Ambient)、漫反射光(Diffuse)和镜面光(Specular)组成。</li><li>环境光(Ambient)一般是一个给定的很小的值。</li><li>漫反射光(Diffuse)强弱由入射光的反向向量与法向量的夹角大小所决定，夹角越大，强度越弱，一般用夹角余弦值替代计算。</li><li>镜面光(Specular)强弱由入射光的反射向量与视线方向的夹角大小所决定，同样夹角越大，强度越弱，一般也使用余弦值替代计算，另还有取它的反光度(Shininess)次幂来作为最终镜面强弱结果。</li></ul><h2 id="冯氏光照模型的不足"><a href="#冯氏光照模型的不足" class="headerlink" title="冯氏光照模型的不足"></a>冯氏光照模型的不足</h2><ul><li>在镜面光分量上，当视线与反射光向量夹角大于90°时，镜面光值将会变为0，在反光度非常小的情况下，会产生较明显的边界情况。</li><li><img src="/2019/02/24/Blinn-Phong光照/advanced_lighting_over_90.png" alt="镜面光临界情况"></li><li><img src="/2019/02/24/Blinn-Phong光照/low_shininess.png" alt="镜面光临界情况"></li></ul><h2 id="Blinn-Phong光照"><a href="#Blinn-Phong光照" class="headerlink" title="Blinn-Phong光照"></a>Blinn-Phong光照</h2><ul><li>Blinn-Phong光照模型是建立在冯氏光照模型的基础上对镜面光计算进行修改的算法，Blinn-Phong模型不再依赖于反射向量，而是采用了半程向量(Halfway Vector)，即光线与视线夹角<br>low_shininess.png一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</li><li><img src="/2019/02/24/Blinn-Phong光照/advanced_lighting_halfway_vector.png" alt="镜面光临界情况"></li><li>当视线正好与反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</li><li>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</li><li>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了：<script type="math/tex; mode=display">\vec H = \frac{\vec L + \vec V}{||\vec L + \vec V||}</script></li><li><p>除此之外，冯氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择冯氏着色时反光度分量的2到4倍。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> lightDir   = <span class="hljs-built_in">normalize</span>(lightPos - FragPos);<br><span class="hljs-type">vec3</span> viewDir    = <span class="hljs-built_in">normalize</span>(viewPos - FragPos);<br><span class="hljs-type">vec3</span> halfwayDir = <span class="hljs-built_in">normalize</span>(lightDir + viewDir);<br><br><span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(normal, halfwayDir), <span class="hljs-number">0.0</span>), shininess);<br><span class="hljs-type">vec3</span> specular = lightColor * spec;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/24/Blinn-Phong光照/compare.png" alt="光照结果对比"></p></li><li><img src="/2019/02/24/Blinn-Phong光照/compare2.png" alt="镜面光对比"></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用OpenGL函数</title>
      <link href="/2019/02/23/%E5%B8%B8%E7%94%A8OpenGL%E5%87%BD%E6%95%B0/"/>
      <url>/2019/02/23/%E5%B8%B8%E7%94%A8OpenGL%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 常用OpenGL函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>游戏角色染色实现</title>
      <link href="/2019/02/19/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%9F%93%E8%89%B2%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/19/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%9F%93%E8%89%B2%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>游戏常用的染色方式。<br><a id="more"></a></p></blockquote><h2 id="什么是游戏角色染色"><a href="#什么是游戏角色染色" class="headerlink" title="什么是游戏角色染色"></a>什么是游戏角色染色</h2><ul><li>我所理解的染色是通过改变游戏角色衣着、饰品、头发、皮肤的颜色来达到不同的视觉效果。</li><li><p>以下分别为DNF、楚留香和奇迹暖暖的染色功能。</p></li><li><p><img src="/2019/02/19/游戏角色染色实现/DNF染色.png" alt="DNF效果"></p></li><li><img src="/2019/02/19/游戏角色染色实现/楚留香染色.png" alt="楚留香效果"></li><li><img src="/2019/02/19/游戏角色染色实现/奇迹暖暖染色.png" alt="奇迹暖暖效果"></li></ul><h2 id="常用的染色方式"><a href="#常用的染色方式" class="headerlink" title="常用的染色方式"></a>常用的染色方式</h2><ul><li>染色，在程序角度而言，其本质为一个颜色映射关系，即给予源色和一定参数，输出目标颜色的过程。</li><li>用式子来表达便是：DestColor = func(BaseColor, Params)</li></ul><h3 id="HSV染色方式"><a href="#HSV染色方式" class="headerlink" title="HSV染色方式"></a>HSV染色方式</h3><ul><li><img src="/2019/02/19/游戏角色染色实现/HSV.png" alt="HSV"></li><li>HSV，即色相（Hue），饱和度（Saturation），亮度（Value）。</li><li>HSV表示颜色的方式与人直观感受更为接近，我们在形容一个物体颜色的时候，经常会不知不觉的说出类似这样的话：“这个苹果好红，红得很深”，“这个黄色很亮眼”等。HSV形容颜色的方式与这种口头描述很相似，色相表示了物体的总体颜色，饱和度则为颜色的深浅，亮度则表示物体的明暗程度。</li><li>楚留香中给出的染色方式便是HSV染色，其能通过调整色相，饱和度和亮度来决定染色结果。</li><li>从上面楚留香染色界面截图可以猜测出，其HSV染色算法的大致过程为：<script type="math/tex; mode=display">BaseHSV = RGB2HSV(BaseColor)</script><script type="math/tex; mode=display">DestHSV = BaseHSV + ChangedHSV</script><script type="math/tex; mode=display">DestColor = HSV2RGB(DestHSV)</script></li><li>关于RGB和HSV的相互转化方式，网上有较多资料，这里不再给出。</li></ul><h3 id="通道混合染色方式"><a href="#通道混合染色方式" class="headerlink" title="通道混合染色方式"></a>通道混合染色方式</h3><ul><li>通道混合的染色方式是以基础颜色作为基准，通过基础颜色和给定的参数混合出新的RGB值。</li><li><p>其数学式子表达如下：</p><script type="math/tex; mode=display">\begin{bmatrix} rr & rg & rb \\ gr & gg & gb \\ br & bg & bb \end{bmatrix}*\begin{bmatrix} R_{source} & G_{source} & B_{source} \end{bmatrix}+\begin{bmatrix} R_{const} & G_{const} & B_{const} \end{bmatrix}=\begin{bmatrix} R & G & B \end{bmatrix}</script></li><li><p>其较为明显的问题是不够HSV直观。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 染色 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 染色 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高级OpenGL（下）</title>
      <link href="/2019/02/09/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2019/02/09/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级OpenGL学习笔记</p><p>高级数据、高级GLSL，几何着色器，实例化，抗锯齿。</p></blockquote><a id="more"></a><h2 id="高级数据-Advanced-Data"><a href="#高级数据-Advanced-Data" class="headerlink" title="高级数据(Advanced Data)"></a>高级数据(Advanced Data)</h2><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><ul><li>OpenGL中的缓冲只是一个管理特定内存块的对象，没有其它更多的功能了。在我们将它绑定到一个缓冲目标(Buffer Target)时，我们才赋予了其意义。当我们绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</li></ul><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>glBufferData</td><td>填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的data参数设置为NULL，那么这个函数将只会分配内存，但不进行填充。这在我们需要预留(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</td></tr><tr><td>glBufferSubData</td><td>填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从何处开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</td></tr><tr><td>glMapBuffer</td><td>请求缓冲内存的指针，直接将数据复制到缓冲当中。调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针。</td></tr><tr><td>glUnmapBuffer</td><td>使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE。</td></tr></tbody></table></div><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// glBufferSubData使用例子</span><br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number">24</span>, <span class="hljs-keyword">sizeof</span>(data), &amp;data); <span class="hljs-comment">// 范围： [24, 24 + sizeof(data)]</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// glMapBuffer、glUnmapBuffer使用例子</span><br><span class="hljs-keyword">float</span> data[] = &#123;<br>  <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">-0.35f</span><br>  ...<br>&#125;;<br>glBindBuffer(GL_ARRAY_BUFFER, buffer);<br><span class="hljs-comment">// 获取指针</span><br><span class="hljs-keyword">void</span> *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);<br><span class="hljs-comment">// 复制数据到内存</span><br><span class="hljs-built_in">memcpy</span>(ptr, data, <span class="hljs-keyword">sizeof</span>(data));<br><span class="hljs-comment">// 记得告诉OpenGL我们不再需要这个指针了</span><br>glUnmapBuffer(GL_ARRAY_BUFFER);<br></code></pre></td></tr></table></figure><h3 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h3><ul><li>通过使用glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。</li><li>之前，我们将顶点的位置、法线、纹理坐标连续且交错的放在一起，即形如123123123123布局。而从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和/或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。</li><li>使用glVertexAttribPointer能将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存，即形如111122223333。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> positions[] = &#123; ... &#125;;<br><span class="hljs-keyword">float</span> normals[] = &#123; ... &#125;;<br><span class="hljs-keyword">float</span> tex[] = &#123; ... &#125;;<br><span class="hljs-comment">// 填充缓冲</span><br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(positions), &amp;positions);<br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(positions), <span class="hljs-keyword">sizeof</span>(normals), &amp;normals);<br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(positions) + <span class="hljs-keyword">sizeof</span>(normals), <span class="hljs-keyword">sizeof</span>(tex), &amp;tex);<br><br><span class="hljs-comment">// 更新顶点属性指针</span><br>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">0</span>);  <br>glVertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)(<span class="hljs-keyword">sizeof</span>(positions)));  <br>glVertexAttribPointer(<br>  <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)(<span class="hljs-keyword">sizeof</span>(positions) + <span class="hljs-keyword">sizeof</span>(normals)));<br></code></pre></td></tr></table></figure><h3 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h3><ul><li><p>glCopyBufferSubData能够让我们相对容易地从一个缓冲中复制数据到另一个缓冲中。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">glCopyBufferSubData</span><span class="hljs-params">(<br>  GLenum readtarget, <span class="hljs-comment">// 复制源</span><br>  GLenum writetarget, <span class="hljs-comment">// 复制目标的缓冲目标</span><br>  GLintptr readoffset, <span class="hljs-comment">// 读偏移</span><br>  GLintptr writeoffset, <span class="hljs-comment">// 写偏移</span><br>  GLsizeiptr size  <span class="hljs-comment">// 读取数据的大小</span><br>)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>我们可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p></li><li>如果读写的两个缓冲均为同类型的缓冲（如，均为顶点数组缓冲），由于不能将两个缓冲绑定至同一个缓冲目标上，故OpenGL提供了GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER这两个缓冲目标。</li><li>使用方式如下：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> vertexData[] = &#123; ... &#125;;<br>glBindBuffer(GL_COPY_READ_BUFFER, vbo1);<br>glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);<br>glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vertexData));<br><br><span class="hljs-comment">// 只将writetarget缓冲绑定为新的缓冲目标类型之一</span><br><span class="hljs-keyword">float</span> vertexData[] = &#123; ... &#125;;<br>glBindBuffer(GL_ARRAY_BUFFER, vbo1);<br>glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);<br>glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vertexData));<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="高级GLSL-Advanced-GLSL"><a href="#高级GLSL-Advanced-GLSL" class="headerlink" title="高级GLSL(Advanced GLSL)"></a>高级GLSL(Advanced GLSL)</h2><h3 id="GLSL的内建变量"><a href="#GLSL的内建变量" class="headerlink" title="GLSL的内建变量"></a>GLSL的内建变量</h3><h4 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h4><h5 id="gl-PointSize（输出变量）"><a href="#gl-PointSize（输出变量）" class="headerlink" title="gl_PointSize（输出变量）"></a>gl_PointSize（输出变量）</h5><ul><li>当图元选择为GL_POINTS时，我们可以通过glPointSize函数来设置渲染出来的点的大小，也可以在顶点着色器中修改这个值。</li><li>GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。</li><li>在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用OpenGL的GL_PROGRAM_POINT_SIZE。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_PROGRAM_POINT_SIZE);<br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 顶点着色器</span><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-built_in">gl_Position</span>.z;  <span class="hljs-comment">// 点的大小会随着观察者距顶点距离变远而增大。</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gl-VertexID（输入变量）"><a href="#gl-VertexID（输入变量）" class="headerlink" title="gl_VertexID（输入变量）"></a>gl_VertexID（输入变量）</h5><ul><li>gl_Position和gl_PointSize都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器提供了一个输入变量gl_VertexID，该只能对它进行读取。</li><li>整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</li></ul><h4 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h4><h5 id="gl-FragCoord（输入变量）"><a href="#gl-FragCoord（输入变量）" class="headerlink" title="gl_FragCoord（输入变量）"></a>gl_FragCoord（输入变量）</h5><ul><li>gl_FragCoord的z分量等于对应片段的深度值。也能使用它的x和y分量来实现一些有趣的效果。</li><li>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。我们已经使用glViewport设定了一个800x600的窗口了，所以片段窗口空间坐标的x分量将在0到800之间，y分量在0到600之间。</li><li>通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()<br>&#123;             <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gl_FragCoord</span>.x &lt; <span class="hljs-number">400</span>)<br>        FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">else</span><br>        FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);        <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="gl-FrontFacing（输入变量）"><a href="#gl-FrontFacing（输入变量）" class="headerlink" title="gl_FrontFacing（输入变量）"></a>gl_FrontFacing（输入变量）</h5><ul><li>如果我们不（启用GL_FACE_CULL来）使用面剔除，那么gl_FrontFacing将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分。</li><li><p>gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是true，否则就是false。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> frontTexture;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> backTexture;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 立方体内部和外部使用不同的纹理</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gl_FrontFacing</span>)<br>        FragColor = <span class="hljs-built_in">texture</span>(frontTexture, TexCoords);<br>    <span class="hljs-keyword">else</span><br>        FragColor = <span class="hljs-built_in">texture</span>(backTexture, TexCoords);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_frontfacing.png" alt="立方体内部和外部使用不同的纹理"></p></li></ul><h5 id="gl-FragDepth（输出变量）"><a href="#gl-FragDepth（输出变量）" class="headerlink" title="gl_FragDepth（输出变量）"></a>gl_FragDepth（输出变量）</h5><ul><li>输入变量gl_FragCoord能让我们读取当前片段的窗口空间坐标，并获取它的深度值，但是它是一个只读(Read-only)变量。我们不能修改片段的窗口空间坐标，但OpenGL提供了名为gl_FragDepth的输出变量，我们可以通过他修改片段的深度值。</li><li><p>要想设置深度值，我们直接写入一个0.0到1.0之间的float值到输出变量就可以了，如果着色器没有写入值到gl_FragDepth，它会自动取用gl_FragCoord.z的值。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gl_FragDepth = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// 这个片段现在的深度值为 0.0</span><br></code></pre></td></tr></table></figure></li><li><p>由自己设置深度值有一个很大的缺点，只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会禁用所有的提前深度测试(Early Depth Testing)。</p></li><li>从OpenGL 4.2起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (depth_&lt;condition&gt;) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> <span class="hljs-built_in">gl_FragDepth</span>;<br></code></pre></td></tr></table></figure></li></ul><p>condition可以为下面的值：</p><div class="table-container"><table><thead><tr><th>条件</th><th>描述</th></tr></thead><tbody><tr><td>any</td><td>默认值。提前深度测试是禁用的，你会损失很多性能</td></tr><tr><td>greater</td><td>你只能让深度值比gl_FragCoord.z更大</td></tr><tr><td>less</td><td>你只能让深度值比gl_FragCoord.z更小</td></tr><tr><td>unchanged</td><td>如果你要写入gl_FragDepth，你将只能写入gl_FragCoord.z的值</td></tr></tbody></table></div><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 420 core // 注意GLSL的版本！</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><span class="hljs-comment">// 片段的深度值进行了递增，但仍然也保留了一些提前深度测试</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">depth_greater</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> <span class="hljs-built_in">gl_FragDepth</span>;<br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">gl_FragDepth</span> = <span class="hljs-built_in">gl_FragCoord</span>.z + <span class="hljs-number">0.1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h3><ul><li>GLSL提供了一个叫做接口块(Interface Block)的东西，来方便组合变量。接口块的声明和struct的声明有点相像，不同的是，现在根据它是一个输入还是输出块(Block)，使用in或out关键字来定义的。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><span class="hljs-comment">// 块名（VS_OUT），需要与片段着色器中保持一致</span><br><span class="hljs-comment">// 实例名（vs_out）可以随意修改。</span><br><span class="hljs-keyword">out</span> VS_OUT<br>&#123;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>&#125; vs_out;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);    <br>    vs_out.TexCoords = aTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-comment">// 块名（VS_OUT），需要与顶点着色器中保持一致</span><br><span class="hljs-comment">// 实例名（vs_out）可以随意修改。</span><br><span class="hljs-keyword">in</span> VS_OUT<br>&#123;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>&#125; fs_in;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> <span class="hljs-built_in">texture</span>;<br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    FragColor = <span class="hljs-built_in">texture</span>(<span class="hljs-built_in">texture</span>, fs_in.TexCoords);   <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接口块，打包了我们希望发送到下一个着色器中的所有输出变量。</li><li>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。</li></ul><h3 id="Uniform缓冲对象"><a href="#Uniform缓冲对象" class="headerlink" title="Uniform缓冲对象"></a>Uniform缓冲对象</h3><ul><li>OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的全局Uniform变量。当使用Uniform缓冲对象的时候，我们只需要设置相关的uniform一次。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。</li></ul><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><br><span class="hljs-comment">// 声明了一个叫做Matrices的Uniform块，它储存了两个4x4矩阵。</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> Matrices<br>&#123;<br>    <span class="hljs-type">mat4</span> projection;<br>    <span class="hljs-type">mat4</span> view;<br>&#125;;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// Uniform块中的变量可以直接访问，不需要加块名作为前缀。</span><br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h4><ul><li>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</li><li>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。</li><li><p>以以下的Uniform块为例：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> ExampleBlock<br>&#123;<br>    <span class="hljs-type">float</span> value;<br>    <span class="hljs-type">vec3</span>  vector;<br>    <span class="hljs-type">mat4</span>  matrix;<br>    <span class="hljs-type">float</span> values[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">bool</span>  boolean;<br>    <span class="hljs-type">int</span>   integer;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Uniform的内存布局有三种，默认情况下的共享(Shared)布局，显式声明每个变量类型布局的std140布局，不能在每个程序中保持不变（非共享）的紧凑(Packed)布局。</p></li></ul><h5 id="共享-Shared-布局"><a href="#共享-Shared-布局" class="headerlink" title="共享(Shared)布局"></a>共享(Shared)布局</h5><ul><li>默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。</li><li>使用共享布局时，GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变。</li><li>需要使用glGetUniformIndices来获得每个uniform变量的偏移量，从而才能准确地填充Uniform缓冲。</li></ul><h5 id="std140布局"><a href="#std140布局" class="headerlink" title="std140布局"></a>std140布局</h5><ul><li>虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。</li><li>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</li><li>GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个N来表示。</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>布局规则</th></tr></thead><tbody><tr><td>标量，比如int和bool</td><td>每个标量的基准对齐量为N。</td></tr><tr><td>向量</td><td>2N或者4N。这意味着vec3的基准对齐量为4N。</td></tr><tr><td>标量或向量的数组</td><td>每个元素的基准对齐量与vec4的相同。</td></tr><tr><td>矩阵</td><td>储存为列向量的数组，每个向量的基准对齐量与vec4的相同。</td></tr><tr><td>结构体</td><td>等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。</td></tr></tbody></table></div><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> ExampleBlock<br>&#123;<br>                     <span class="hljs-comment">// 基准对齐量       // 对齐偏移量</span><br>    <span class="hljs-type">float</span> value;     <span class="hljs-comment">// 4               // 0</span><br>    <span class="hljs-type">vec3</span> vector;     <span class="hljs-comment">// 16              // 16  (必须是16的倍数，所以 4-&gt;16)</span><br>    <span class="hljs-type">mat4</span> matrix;     <span class="hljs-comment">// 16              // 32  (列 0)</span><br>                     <span class="hljs-comment">// 16              // 48  (列 1)</span><br>                     <span class="hljs-comment">// 16              // 64  (列 2)</span><br>                     <span class="hljs-comment">// 16              // 80  (列 3)</span><br>    <span class="hljs-type">float</span> values[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 16              // 96  (values[0])</span><br>                     <span class="hljs-comment">// 16              // 112 (values[1])</span><br>                     <span class="hljs-comment">// 16              // 128 (values[2])</span><br>    <span class="hljs-type">bool</span> boolean;    <span class="hljs-comment">// 4               // 144</span><br>    <span class="hljs-type">int</span> integer;     <span class="hljs-comment">// 4               // 148 (必须是4的倍数)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用计算后的偏移量值，根据std140布局的规则，我们就能使用像是glBufferSubData的函数将变量数据按照偏移量填充进缓冲中了。虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 更新uniform变量boolean</span><br>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);<br><span class="hljs-keyword">int</span> b = <span class="hljs-literal">true</span>; <span class="hljs-comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span><br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-number">144</span>, <span class="hljs-number">4</span>, &amp;b);<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h5 id="紧凑-Packed-布局"><a href="#紧凑-Packed-布局" class="headerlink" title="紧凑(Packed)布局"></a>紧凑(Packed)布局</h5><ul><li>不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的。</li></ul><h4 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h4><ul><li><p>调用glGenBuffers，创建一个Uniform缓冲对象。再将缓冲对象绑定到GL_UNIFORM_BUFFER目标，最后调用glBufferData，分配足够的内存。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uboExampleBlock;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;uboExampleBlock);<br>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);<br>glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number">152</span>, <span class="hljs-literal">NULL</span>, GL_STATIC_DRAW); <span class="hljs-comment">// 分配152字节的内存</span><br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>在OpenGL上下文中，定义了一些绑定点(Binding Point)，我们可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。</p></li><li><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_binding_points.png" alt="绑定点"></li></ul><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>glUniformBlockBinding</td><td>将Uniform块绑定到一个特定的绑定点中，它的第一个参数是一个 <em>程序对象</em> ，之后是一个 <em>Uniform块索引</em> 和 <em>链接到的绑定点</em> 。</td></tr><tr><td>glGetUniformBlockIndex</td><td>获取Uniform块索引(Uniform Block Index)使用，接受一个程序对象和Uniform块的名称。</td></tr><tr><td>glBindBufferBase</td><td>所需参数为 目标，绑定点索引，Uniform缓冲对象。</td></tr><tr><td>glBindBufferRange</td><td>所需参数为 目标，绑定点索引，Uniform缓冲对象，附加偏移量，大小。使用glBindBufferRange函数，你可以让多个不同的Uniform块绑定到同一个Uniform缓冲对象上。</td></tr></tbody></table></div><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取shaderA中名为Lights的Uniform块索引，将绑定到2号绑定点中。</span><br><span class="hljs-comment">// 需要注意对每个着色器重复这一步骤。</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lights_index = glGetUniformBlockIndex(shaderA.ID, <span class="hljs-string">"Lights"</span>);   <br>glUniformBlockBinding(shaderA.ID, lights_index, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">从OpenGL <span class="hljs-number">4.2</span>版本起，<br>可以添加一个布局标识符，<br>显式地将Uniform块的绑定点储存在着色器中，<br>下面的代码显式地设置了Lights Uniform块的绑定点。<br><br>layout(std140, binding = <span class="hljs-number">2</span>) uniform Lights &#123; ... &#125;;<br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数将uboExampleBlock链接到绑定点2</span><br>glBindBufferBase(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span>, uboExampleBlock);<br><span class="hljs-comment">// 或</span><br>glBindBufferRange(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span>, uboExampleBlock, <span class="hljs-number">0</span>, <span class="hljs-number">152</span>);<br></code></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>将投影和模型矩阵存储到一个叫做Matrices的Uniform块中，用四个shader分别绘制立方体。</li><li>四个shader公用同一个份顶点着色器代码。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> Matrices<br>&#123;<br>    <span class="hljs-type">mat4</span> projection;<br>    <span class="hljs-type">mat4</span> view;<br>&#125;;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要对每个shader都做一次，将顶点着色器的Uniform块设置为绑定点0</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, <span class="hljs-string">"Matrices"</span>);<br><br>glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 创建Uniform缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uboMatrices;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;uboMatrices);<br><br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br><span class="hljs-comment">// GLM矩阵类型的大小直接对应于GLSL中的mat4，其中会存储两个矩阵，故大小设置为2个mat4</span><br>glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(glm::mat4), <span class="hljs-literal">NULL</span>, GL_STATIC_DRAW);<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将Uniform缓冲对象链接到绑定点0</span><br>glBindBufferRange(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>, uboMatrices, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(glm::mat4));<br><br><span class="hljs-comment">// 将projection矩阵数据写入</span><br>glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (<span class="hljs-keyword">float</span>)SCR_WIDTH / (<span class="hljs-keyword">float</span>)SCR_HEIGHT, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(glm::mat4), glm::value_ptr(projection));<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">while</span>(loop) &#123;<br>  ...<br>  <span class="hljs-comment">// 在loop中只需要更新一次view矩阵</span><br>  glm::mat4 view = camera.GetViewMatrix();<br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-keyword">sizeof</span>(glm::mat4), <span class="hljs-keyword">sizeof</span>(glm::mat4), glm::value_ptr(view));<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_uniform_buffer_objects.png" alt="例子"></li></ul><hr><h2 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器(Geometry Shader)"></a>几何着色器(Geometry Shader)</h2><ul><li><img src="/2019/02/09/高级OpenGL（下）/pipeline.png" alt="图形渲染管线"></li><li>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换，如生成更多的顶点或变成其他图元。</li></ul><h3 id="使用几何着色器"><a href="#使用几何着色器" class="headerlink" title="使用几何着色器"></a>使用几何着色器</h3><h4 id="几何着色器例子"><a href="#几何着色器例子" class="headerlink" title="几何着色器例子"></a>几何着色器例子</h4><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-comment">// 声明从顶点着色器输入的图元类型</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">points</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-comment">// 指定几何着色器输出的图元类型</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangle_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">5</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-type">void</span> build_house(<span class="hljs-type">vec4</span> position)<br>&#123;    <br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>(<span class="hljs-number">-0.2</span>, <span class="hljs-number">-0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 1:左下</span><br>    <span class="hljs-built_in">EmitVertex</span>();   <br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.2</span>, <span class="hljs-number">-0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 2:右下</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>(<span class="hljs-number">-0.2</span>,  <span class="hljs-number">0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 3:左上</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.2</span>,  <span class="hljs-number">0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 4:右上</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.0</span>,  <span class="hljs-number">0.4</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 5:顶部</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;    <br>    build_house(<span class="hljs-built_in">gl_in</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">gl_Position</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从上面的例子中可以看到，几何着色器顶部需要声明从顶点着色器输入的图元类型，需要在 <font color="#D2691E" size="4"> <em>in</em> </font> 关键字前声明一个布局修饰符(Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值：</li><li>提供给glDrawArrays渲染函数的几乎所有图元：</li></ul><div class="table-container"><table><thead><tr><th>shader中的输入图元</th><th>glDrawArrays中对应的图元</th><th>最小顶点数</th></tr></thead><tbody><tr><td>points</td><td>绘制GL_POINTS图元时</td><td>1</td></tr><tr><td>lines</td><td>绘制GL_LINES或GL_LINE_STRIP时</td><td>2</td></tr><tr><td>lines_adjacency</td><td>GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY</td><td>4</td></tr><tr><td>triangles</td><td>GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN</td><td>3</td></tr><tr><td>triangles_adjacency</td><td>GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY</td><td>6</td></tr></tbody></table></div><ul><li>同时，也需要指定几何着色器输出的图元类型，这需要在<font color="#D2691E" size="4"> <em>out</em> </font>关键字前面加一个布局修饰符，并设置一个它最大能够输出的顶点数量（如果你超过了这个值，OpenGL将不会绘制多出的顶点），上面的例子中设置了输出为triangle_strip且最大顶点数为5个。</li><li>输出布局修饰符可以接受的图元值：</li></ul><div class="table-container"><table><thead><tr><th>shader中的输出图元</th><th>含义</th><th>最小顶点数</th></tr></thead><tbody><tr><td>points</td><td>点</td><td>1</td></tr><tr><td>line_strip</td><td>按顺序连接所有给定点的一条线</td><td>2</td></tr><tr><td>triangle_strip</td><td>每3个临近的顶点将会形成一个三角形，如给出5个点，按(1, 2, 3)、(2, 3, 4)、(3, 4, 5)这样的分配来绘制3个三角形</td><td>3</td></tr></tbody></table></div><ul><li>例子往下看，在main函数中，通过内建变量gl_in来访问传入的图元，可以看出gl_in是一个数组，其内部实现类似于一个包含多个特征的结构体。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 内建变量gl_in的大概实现</span><br><span class="hljs-comment">// 其为一个接口块</span><br><span class="hljs-comment">// 其包含gl_Position位置信息，gl_PointSize大小信息</span><br><span class="hljs-comment">// gl_ClipDistance是为顶点裁剪提供了向前兼容所使用</span><br>in gl_Vertex<br>&#123;<br>    vec4  gl_Position;<br>    <span class="hljs-keyword">float</span> gl_PointSize;<br>    <span class="hljs-keyword">float</span> gl_ClipDistance[];<br>&#125; gl_in[];<br></code></pre></td></tr></table></figure><ul><li><p>查看main函数中调用的build_house函数，在每次对position进行位移之后，都调用了EmitVertex()函数，因为在调用了该函数后，gl_Position中的向量会被添加到图元中来；在函数最后调用了EndPrimitive()函数，这样所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个EmitVertex调用之后重复调用EndPrimitive能够生成多个图元。</p></li><li><p>至此，整段几何着色器的代码已解析完毕，其实现的功能便是接受一个点图元作为输入，以该点位中心，通过5次位移，生成5个新点，并将它们合成一个triangle_strip图元，该图元将会绘制3个三角形。</p></li></ul><h4 id="将例子显示"><a href="#将例子显示" class="headerlink" title="将例子显示"></a>将例子显示</h4><ul><li><p>出于简单考虑，顶点着色器和片段着色器都进行硬编码，写死一些数据即可。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vs</span><br><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br><br><span class="hljs-comment">// fs</span><br><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于几何着色器，我们也需要进行编译和连接，其传入的着色器类型为<font color="#D2691E" size="4"> <em>GL_GEOMETRY_SHADER</em> </font></p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">geometryShader = glCreateShader(GL_GEOMETRY_SHADER);<br>glShaderSource(geometryShader, <span class="hljs-number">1</span>, &amp;gShaderCode, <span class="hljs-literal">NULL</span>);<br>glCompileShader(geometryShader);  <br>...<br>glAttachShader(program, geometryShader);<br>glLinkProgram(program);<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/geometry_sample.png" alt="效果显示"></p></li></ul><h3 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h3><ul><li>将物体的每个图元向法线方向进行小量位移，我们可以轻易得到类似物体爆破的效果。几何着色器提供了让我们访问及操作图元的可能，通过几何着色器，我们便可以实现爆破效果。</li><li><img src="/2019/02/09/高级OpenGL（下）/geometry_explode.png" alt="效果显示"></li></ul><h3 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h3><ul><li>首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。</li><li><p>伪代码：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">shader.use();<br>DrawScene();<br>normalDisplayShader.use();<br>DrawScene();<br></code></pre></td></tr></table></figure></li><li><p>几何着色器接受的位置向量是剪裁空间坐标，所以需要将法向量变换到相同的空间中，这一步可以在顶点着色器中完成。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aNormal;<br><br><span class="hljs-keyword">out</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> normal;<br>&#125; vs_out;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">mat3</span> normalMatrix = <span class="hljs-type">mat3</span>(<span class="hljs-built_in">transpose</span>(<span class="hljs-built_in">inverse</span>(view * model)));<br>    vs_out.normal = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(projection * <span class="hljs-type">vec4</span>(normalMatrix * aNormal, <span class="hljs-number">0.0</span>)));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangles</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">line_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">6</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">in</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> normal;<br>&#125; gs_in[];<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> MAGNITUDE = <span class="hljs-number">0.4</span>;<br><br><span class="hljs-type">void</span> GenerateLine(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[<span class="hljs-keyword">index</span>].<span class="hljs-built_in">gl_Position</span>;<br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[<span class="hljs-keyword">index</span>].<span class="hljs-built_in">gl_Position</span> + <span class="hljs-type">vec4</span>(gs_in[<span class="hljs-keyword">index</span>].normal, <span class="hljs-number">0.0</span>) * MAGNITUDE;<br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    GenerateLine(<span class="hljs-number">0</span>); <span class="hljs-comment">// 第一个顶点法线</span><br>    GenerateLine(<span class="hljs-number">1</span>); <span class="hljs-comment">// 第二个顶点法线</span><br>    GenerateLine(<span class="hljs-number">2</span>); <span class="hljs-comment">// 第三个顶点法线</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从模型内部往外看，可以看到每个顶点的法线均被显示出来。</li><li><img src="/2019/02/09/高级OpenGL（下）/geometry_shownormal.png" alt="效果显示"></li></ul><hr><h2 id="实例化-Instancing"><a href="#实例化-Instancing" class="headerlink" title="实例化(Instancing)"></a>实例化(Instancing)</h2><ul><li>对于要绘制很多相同模型的场景，过去我们使用的方式是要创建多少个实例则调用多少次glDrawArrays或glDrawElements，这种做法十分消耗性能。</li><li>使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令GPU去渲染却未必。</li><li>如果模型都是使用同一份顶点数据，只是进行了不同的世界空间转换，我们可以将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，这就是<font color="#D2691E" size="5"> <em>实例化</em> </font>。</li><li>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。</li></ul><h3 id="glDrawArraysInstanced和glDrawElementsInstanced"><a href="#glDrawArraysInstanced和glDrawElementsInstanced" class="headerlink" title="glDrawArraysInstanced和glDrawElementsInstanced"></a>glDrawArraysInstanced和glDrawElementsInstanced</h3><ul><li>glDrawArraysInstanced和glDrawElementsInstanced分别对应glDrawArrays和glDrawElements，相比只是多了一个叫做实例数量(Instance Count)的参数，它能够设置我们需要渲染的实例个数。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindVertexArray(quadVAO);<br>glDrawArraysInstanced(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="gl-InstanceID"><a href="#gl-InstanceID" class="headerlink" title="gl_InstanceID"></a>gl_InstanceID</h3><ul><li>在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。</li><li>使用实例化渲染函数进行物体渲染后，物体会集中在同一个位置，并没有太大用处，通过gl_InstanceID，我们可以得知当前正在渲染哪个实例，从而在shader中进行针对性处理。</li><li><p>利用gl_InstanceID对方形进行缩小及获得位置偏移量：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> offsets[<span class="hljs-number">100</span>];<br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec2</span> pos = aPos * (<span class="hljs-built_in">gl_InstanceID</span> / <span class="hljs-number">100.0</span>);<br>    <span class="hljs-type">vec2</span> <span class="hljs-keyword">offset</span> = offsets[<span class="hljs-built_in">gl_InstanceID</span>];<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(pos + <span class="hljs-keyword">offset</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fColor = aColor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/instancing_InstanceID.png" alt="利用gl_InstanceID对方形进行缩小"></p></li></ul><h3 id="实例化数组-Instanced-Array"><a href="#实例化数组-Instanced-Array" class="headerlink" title="实例化数组(Instanced Array)"></a>实例化数组(Instanced Array)</h3><ul><li>使用uniform数组来获取每个实例位置的方式能力终究有限，当实例数量远超100的时候，发送至着色器的uniform数据大小将会超过上限。</li><li>实例化数组(Instanced Array)能够有效解决传输数据过大的问题。它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</li><li><p>将位置偏移量改为使用实例化数组来实现：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor;<br><span class="hljs-comment">// 实例化数组</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aOffset;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec2</span> pos = aPos * (<span class="hljs-built_in">gl_InstanceID</span> / <span class="hljs-number">100.0</span>);<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(pos + aOffset, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fColor = aColor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实例化数组的配置方式：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> instanceVBO;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;instanceVBO);<br>glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);<br>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(glm::vec2) * <span class="hljs-number">100</span>, &amp;translations[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br>glEnableVertexAttribArray(<span class="hljs-number">2</span>);<br>glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);<br>glVertexAttribPointer(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 告诉OpenGL什么时候更新顶点属性的内容至新一组数据</span><br>glVertexAttribDivisor(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>上面代码最后一处的<font color="#D2691E" size="4"> <em>glVertexAttribDivisor</em> </font>用于告知OpenGL合适更新顶点属性数据。其接受两个参数，第一个参数是顶点属性，在上面的例子中位置偏移量的顶点属性值是2；第二个参数是属性除数，即告知OpenGL每隔多少个实例更新一次顶点数据，默认值为0，表示不刷新，现在传1，表示每渲染一个新实例后便更新顶点属性。</p></li></ul><h3 id="使用实例化绘制小行星带"><a href="#使用实例化绘制小行星带" class="headerlink" title="使用实例化绘制小行星带"></a>使用实例化绘制小行星带</h3><ul><li>小行星带中含有成千上万的小陨石，是使用实例化的较好例子。</li><li><p>我们使用实例化数组来存放陨石位置，其对应的顶点着色器代码如下：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoords;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">mat4</span> instanceMatrix;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * instanceMatrix * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    TexCoords = aTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于陨石模型的每个网格，我们需要通过glVertexAttribDivisor设置每渲染一个物体则更新数据，在Loop中使用glDrawElementsInstanced绘制多个陨石。</p></li><li><p>现在我们改为使用mat4的顶点属性来存储model矩阵。然而，当我们顶点属性的类型大于vec4时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个vec4。因为一个mat4本质上是4个vec4，我们需要为这个矩阵预留4个顶点属性。因为我们将它的位置值设置为3，矩阵每一列的顶点属性位置值就是3、4、5和6。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 顶点缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> buffer;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;buffer);<br>glBindBuffer(GL_ARRAY_BUFFER, buffer);<br>glBufferData(GL_ARRAY_BUFFER, amount * <span class="hljs-keyword">sizeof</span>(glm::mat4), &amp;modelMatrices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rock.meshes.size(); i++)<br>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> VAO = rock.meshes[i].VAO;<br>    glBindVertexArray(VAO);<br>    <span class="hljs-comment">// 顶点属性</span><br>    GLsizei vec4Size = <span class="hljs-keyword">sizeof</span>(glm::vec4);<br>    glEnableVertexAttribArray(<span class="hljs-number">3</span>);<br>    glVertexAttribPointer(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>    glEnableVertexAttribArray(<span class="hljs-number">4</span>);<br>    glVertexAttribPointer(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(vec4Size));<br>    glEnableVertexAttribArray(<span class="hljs-number">5</span>);<br>    glVertexAttribPointer(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(<span class="hljs-number">2</span> * vec4Size));<br>    glEnableVertexAttribArray(<span class="hljs-number">6</span>);<br>    glVertexAttribPointer(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(<span class="hljs-number">3</span> * vec4Size));<br><br>    glVertexAttribDivisor(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>);<br><br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>&#125;<br><br>...<br><br><span class="hljs-comment">// 绘制小行星</span><br>instanceShader.use();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rock.meshes.size(); i++)<br>&#123;<br>    glBindVertexArray(rock.meshes[i].VAO);<br>    glDrawElementsInstanced(<br>        GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, <span class="hljs-number">0</span>, amount<br>    );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/instancing_planet.png" alt="小行星带"></p></li></ul><hr><h2 id="抗锯齿-Anti-Aliasing"><a href="#抗锯齿-Anti-Aliasing" class="headerlink" title="抗锯齿(Anti Aliasing)"></a>抗锯齿(Anti Aliasing)</h2><ul><li>在绘制物体的过程中，由于某个具体像素点要么选择采样要么选择不采样，导致在高分辨率的情况下，其边缘会产生较严重的锯齿现象。</li><li>引用知乎文刀秋二的话来讲：“锯齿的来源是因为场景的定义在三维空间中是连续的，而最终显示的像素则是一个离散的二维数组。所以判断一个点到底没有被某个像素覆盖的时候单纯是一个“有”或者“没有”问题，丢失了连续性的信息，导致锯齿。”</li></ul><h3 id="锯齿产生原因"><a href="#锯齿产生原因" class="headerlink" title="锯齿产生原因"></a>锯齿产生原因</h3><ul><li><img src="/2019/02/09/高级OpenGL（下）/pipeline.png" alt="图形渲染管线"></li><li>物体边缘产生锯齿与光栅器将顶点数据转化为片段的方式有关，光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。</li><li><p>光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。</p></li><li><p><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_rasterization.png" alt="光栅化"></p></li><li>上图是渲染一个三角形光栅化的过程，左图中每个像素点中心都有一个采样点，当采样点处于三角形中时，该像素会生成一个片段。根据该方式得到的右图的片段，该片段也是最终渲染在屏幕上的效果，从此处可以看出锯齿产生的原因。</li></ul><h3 id="多重采样抗锯齿-Multisample-Anti-aliasing-MSAA"><a href="#多重采样抗锯齿-Multisample-Anti-aliasing-MSAA" class="headerlink" title="多重采样抗锯齿(Multisample Anti-aliasing, MSAA)"></a>多重采样抗锯齿(Multisample Anti-aliasing, MSAA)</h3><ul><li><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_sample_points.png" alt="多重采样"></li><li>由于仅通过对像素中心点是否在物体内来判断是否生成片段的方式容易出现锯齿，一个更好的方式是增加采样点，通过被物体所包含的采样点的数量来决定是否生成片段及片段的颜色缓冲大小。</li><li>右图是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。颜色缓冲的大小会随着子采样点的增加而增加。</li><li><img src="/2019/02/09/高级OpenGL（下）/msaa.jpg" alt="MSAA工作方式"></li><li>MSAA的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。</li></ul><h3 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h3><ul><li>使用MSAA需要一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。</li><li><p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。在GLFW中，需要在创建窗口之前调用glfwWindowHint来设置包含多重采样的样本数量。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glfwWindowHint(GLFW_SAMPLES, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure></li><li><p>在调用了上述接口后，再使用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。另外，还需要启用GL_MULTISAMPLE来确保启用了多重采样。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_MULTISAMPLE);<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_sample.png" alt="开启MSAA对比"></p></li></ul><h3 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h3><ul><li>若想要使用自己的帧缓冲来进行离屏渲染，那么就必须要手动生成多重采样缓冲。</li><li>与普通帧缓冲创建使用过程类似，只需要将附件改成对应的多重采样附件。</li></ul><h4 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);<br>glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);<br>glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, <span class="hljs-number">0</span>);<br><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>为了创建一个支持储存多个采样点的纹理，我们使用<font color="#D2691E" size="4"> <em>glTexImage2DMultisample</em> </font>来替代glTexImage2D，它的纹理目标是GL_TEXTURE_2D_MULTISAPLE。</li><li>它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。</li><li>使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是GL_TEXTURE_2D_MULTISAMPLE。</li></ul><h4 id="多重采样渲染缓冲对象"><a href="#多重采样渲染缓冲对象" class="headerlink" title="多重采样渲染缓冲对象"></a>多重采样渲染缓冲对象</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br>glRenderbufferStorageMultisample(GL_RENDERBUFFER, <span class="hljs-number">4</span>, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);<br>glBindRenderbuffer(GL_RENDERBUFFER, <span class="hljs-number">0</span>);<br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br></code></pre></td></tr></table></figure><ul><li>我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将glRenderbufferStorage的调用改为<font color="#D2691E" size="4"> <em>glRenderbufferStorageMultisample</em> </font>就可以了。</li></ul><h4 id="渲染到多重采样帧缓冲"><a href="#渲染到多重采样帧缓冲" class="headerlink" title="渲染到多重采样帧缓冲"></a>渲染到多重采样帧缓冲</h4><ul><li>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</li><li>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过<font color="#D2691E" size="4"> <em>glBlitFramebuffer</em> </font>来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</li><li><p><font color="#D2691E" size="4"> <em>glBlitFramebuffer</em> </font>会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);<br>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);<br>glBlitFramebuffer(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/offscreen.png" alt="离屏MSAA"></p></li></ul><h3 id="自定义抗锯齿算法"><a href="#自定义抗锯齿算法" class="headerlink" title="自定义抗锯齿算法"></a>自定义抗锯齿算法</h3><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2DMS</span> screenTextureMS;<br><span class="hljs-type">vec4</span> colorSample = <span class="hljs-built_in">texelFetch</span>(screenTextureMS, TexCoords, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 第4个子样本</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 高级OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高级OpenGL（上）</title>
      <link href="/2018/12/23/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2018/12/23/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级OpenGL学习笔记</p><p>深度测试，模板测试，混合，面剔除，帧缓冲，立方体贴图。</p></blockquote><a id="more"></a><h2 id="深度测试-Depth-testing"><a href="#深度测试-Depth-testing" class="headerlink" title="深度测试(Depth testing)"></a>深度测试(Depth testing)</h2><ul><li>将3D世界中的东西用2D屏幕来表示，我们需要知道物体的前后关系以让物体以正确的方式渲染。在OpenGL中是通过储存在深度缓冲（或z缓冲(z-buffer)）中的深度值(Depth Value)来确定一个片段是处于其它片段后方的。</li></ul><h3 id="深度测试运行机制"><a href="#深度测试运行机制" class="headerlink" title="深度测试运行机制"></a>深度测试运行机制</h3><h4 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h4><ul><li>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。</li></ul><h4 id="深度测试规则"><a href="#深度测试规则" class="headerlink" title="深度测试规则"></a>深度测试规则</h4><ul><li><p>深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用GL_DEPTH_TEST选项来启用它：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_DEPTH_TEST);<br></code></pre></td></tr></table></figure></li><li><p>当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值（深度缓冲中储存该片段的z值）。如果深度测试失败了，片段将会被丢弃。</p></li><li><p>因为深度被缓存，一般情况下，在每个渲染迭代前会使用GL_DEPTH_BUFFER_BIT来清除深度缓冲：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br></code></pre></td></tr></table></figure></li><li><p>OpenGL允许我们禁用深度缓冲的写入：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glDepthMask(GL_FALSE);<br></code></pre></td></tr></table></figure></li></ul><h4 id="深度测试时机"><a href="#深度测试时机" class="headerlink" title="深度测试时机"></a>深度测试时机</h4><ul><li>深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后，我们将在下一节中讨论）在屏幕空间中运行的。屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。</li></ul><h4 id="提前深度测试"><a href="#提前深度测试" class="headerlink" title="提前深度测试"></a>提前深度测试</h4><ul><li>现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</li><li>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。</li></ul><hr><h3 id="深度测试函数"><a href="#深度测试函数" class="headerlink" title="深度测试函数"></a>深度测试函数</h3><ul><li>OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glDepthFunc(GL_LESS);<br></code></pre></td></tr></table></figure></li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>GL_ALWAYS</td><td>永远通过深度测试</td></tr><tr><td>GL_NEVER</td><td>永远不通过深度测试</td></tr><tr><td>GL_LESS</td><td>在片段深度值小于缓冲的深度值时通过测试</td></tr><tr><td>GL_EQUAL</td><td>在片段深度值等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_LEQUAL</td><td>在片段深度值小于等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_GREATER</td><td>在片段深度值大于缓冲区的深度值时通过测试</td></tr><tr><td>GL_NOTEQUAL</td><td>在片段深度值不等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_GEQUAL</td><td>在片段深度值大于等于缓冲区的深度值时通过测试</td></tr></tbody></table></div><hr><h3 id="深度值"><a href="#深度值" class="headerlink" title="深度值"></a>深度值</h3><h4 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h4><ul><li>使用线性深度缓冲(Linear Depth Buffer)会使得对1000单位远的物体和只有1单位远的充满细节的物体使用相同的精度，这与投影性质不相符，我们希望在近处有更精细的精度，而远处的精度可以很粗糙。</li><li>由投影矩阵所得的深度缓冲值函数：<script type="math/tex; mode=display">F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}</script></li><li><img src="/2018/12/23/高级OpenGL（上）/depth_non_linear_graph.png" alt="z值和最终的深度缓冲值之间的非线性关系"></li></ul><h4 id="深度值可视化"><a href="#深度值可视化" class="headerlink" title="深度值可视化"></a>深度值可视化</h4><ul><li><p>片段着色器改为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    FragColor = vec4(vec3(gl_FragCoord.z), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可视化的深度值如下图，几乎全白，很靠近物体的时候才会有黑色，体现了深度值的非线性特性。</p></li><li><img src="/2018/12/23/高级OpenGL（上）/depth_testing_depth.png" alt="深度值可视化"></li></ul><hr><h3 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h3><ul><li>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</li><li>由于深度值非线性，远近平面距离短时处于较远处的物体更容易出现深度冲突。</li><li><img src="/2018/12/23/高级OpenGL（上）/z_fighting.png" alt="深度冲突"></li><li><img src="/2018/12/23/高级OpenGL（上）/depth_testing_zfighting.png" alt="深度冲突"></li></ul><h4 id="防止深度冲突"><a href="#防止深度冲突" class="headerlink" title="防止深度冲突"></a>防止深度冲突</h4><ul><li><p>第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p></li><li><p>第二个技巧是尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。</p></li><li><p>另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p></li></ul><hr><h2 id="模板测试-Stencil-testing"><a href="#模板测试-Stencil-testing" class="headerlink" title="模板测试(Stencil testing)"></a>模板测试(Stencil testing)</h2><ul><li>一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。<blockquote><p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p></blockquote></li></ul><h3 id="使用模板缓冲"><a href="#使用模板缓冲" class="headerlink" title="使用模板缓冲"></a>使用模板缓冲</h3><h4 id="大体步骤"><a href="#大体步骤" class="headerlink" title="大体步骤"></a>大体步骤</h4><ol><li><p>启用模板缓冲的写入。可以启用GL_STENCIL_TEST来启用模板测试。和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_STENCIL_TEST);<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<br></code></pre></td></tr></table></figure></li><li><p>和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p></li><li>禁用模板缓冲的写入。</li><li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li></ol><h4 id="掩码设置"><a href="#掩码设置" class="headerlink" title="掩码设置"></a>掩码设置</h4><ul><li>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。</li><li>大部分情况下你都只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glStencilMask(<span class="hljs-number">0xFF</span>); <span class="hljs-comment">// 每一位写入模板缓冲时都保持原样</span><br>glStencilMask(<span class="hljs-number">0x00</span>); <span class="hljs-comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h4><h5 id="glStencilFunc"><a href="#glStencilFunc" class="headerlink" title="glStencilFunc"></a>glStencilFunc</h5><ul><li>glStencilFunc决定模板与何值进行何种比较，且支持比较前进行掩码计算。</li><li>glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：<ol><li>func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li><li>ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li><li>mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。</li></ol></li></ul><h5 id="glStencilOp"><a href="#glStencilOp" class="headerlink" title="glStencilOp"></a>glStencilOp</h5><ul><li>glStencilOp告诉OpenGL如何更新缓冲。</li><li>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个参数：<ol><li>sfail：模板测试失败时采取的行为。</li><li>dpfail：模板测试通过，但深度测试失败时采取的行为。</li><li>dppass：模板测试和深度测试都通过时采取的行为。</li></ol></li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>GL_KEEP</td><td>保持当前储存的模板值</td></tr><tr><td>GL_ZERO</td><td>将模板值设置为0</td></tr><tr><td>GL_REPLACE</td><td>将模板值设置为glStencilFunc函数设置的ref值</td></tr><tr><td>GL_INCR</td><td>如果模板值小于最大值则将模板值加1</td></tr><tr><td>GL_INCR_WRAP</td><td>与GL_INCR一样，但如果模板值超过了最大值则归零</td></tr><tr><td>GL_DECR</td><td>如果模板值大于最小值则将模板值减1</td></tr><tr><td>GL_DECR_WRAP</td><td>与GL_DECR一样，但如果模板值小于0则将其设置为最大值</td></tr><tr><td>GL_INVERT</td><td>按位翻转当前的模板缓冲值</td></tr></tbody></table></div><ul><li>默认情况下glStencilOp是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</li></ul><hr><h3 id="模板缓冲例子"><a href="#模板缓冲例子" class="headerlink" title="模板缓冲例子"></a>模板缓冲例子</h3><h4 id="物体轮廓"><a href="#物体轮廓" class="headerlink" title="物体轮廓"></a>物体轮廓</h4><ul><li><p>绘制轮廓步骤</p><ol><li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li><li>渲染物体。</li><li>禁用模板写入以及深度测试。</li><li>将每个物体缩放一点点。</li><li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li><li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li><li>再次启用模板写入和深度测试。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 开启模板缓冲</span><br>glEnable(GL_DEPTH_TEST);<br><span class="hljs-comment">// 设置测试通过时的替换模板值</span><br>glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  <br><br><span class="hljs-comment">// 清空模板缓冲</span><br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<br><br>glStencilMask(<span class="hljs-number">0x00</span>); <span class="hljs-comment">// 记得保证我们在绘制地板的时候不会更新模板缓冲</span><br>normalShader.use();<br>DrawFloor()  <br><br><span class="hljs-comment">// 第一次绘制物体，让片段都通过模板测试。</span><br>glStencilFunc(GL_ALWAYS, <span class="hljs-number">1</span>, <span class="hljs-number">0xFF</span>);<br>glStencilMask(<span class="hljs-number">0xFF</span>);<br>DrawTwoContainers();<br><br><span class="hljs-comment">// 第二次绘制物体，禁止模板缓冲写入，将物体放大一点点，只通过模板缓冲值不等于1的片段。</span><br>glStencilFunc(GL_NOTEQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">0xFF</span>);<br>glStencilMask(<span class="hljs-number">0x00</span>);<br>glDisable(GL_DEPTH_TEST);<br>shaderSingleColor.use();<br>DrawTwoScaledUpContainers();<br>glStencilMask(<span class="hljs-number">0xFF</span>);<br>glEnable(GL_DEPTH_TEST);<br></code></pre></td></tr></table></figure></li></ol></li><li><p><img src="/2018/12/23/高级OpenGL（上）/物体轮廓.jpg" alt="物体轮廓"></p></li></ul><hr><h2 id="混合-Blending"><a href="#混合-Blending" class="headerlink" title="混合(Blending)"></a>混合(Blending)</h2><ul><li>OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。</li></ul><h3 id="丢弃片段-discard"><a href="#丢弃片段-discard" class="headerlink" title="丢弃片段(discard)"></a>丢弃片段(discard)</h3><ul><li>在绘制物体时，有些时候，我们会希望丢弃某些片段，如alpha为0的片段。</li><li><p>GLSL给了我们discard命令，一旦被调用，它就会保证片段不会被进一步处理，所以就不会进入颜色缓冲。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec2 TexCoords;<br><br>uniform sampler2D texture1;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    vec4 texColor = texture(texture1, TexCoords);<br>    <span class="hljs-keyword">if</span>(texColor.a &lt; <span class="hljs-number">0.1</span>)<br>        discard;<br>    FragColor = texColor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/23/高级OpenGL（上）/discard.png" alt="使用discard去掉alpha值小于1的片段"></p></li><li>从上图可以看出，采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值，从而造成草头上有点绿。（这是因为它的环绕方式被设置为了GL_REPEAT，将纹理的环绕方式设置为GL_CLAMP_TO_EDGE即可解决）。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br></code></pre></td></tr></table></figure></li></ul><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><ul><li>截至上面，我们对一个片段的操作均为要么丢弃，要么渲染，并未能做到渲染多个透明度级别的图像。</li><li>OpenGL提供了glEnable(GL_BLEND)方法来启用混合，但我们需要告知OpenGL如何混合。</li></ul><h4 id="混合方程"><a href="#混合方程" class="headerlink" title="混合方程"></a>混合方程</h4><script type="math/tex; mode=display">\vec C_{result} = \vec C_{source} * \vec F_{source} + \vec C_{destination} * \vec F_{destination}</script><p>$\vec C_{source}$ ：源颜色向量，这是源自纹理的颜色向量。</p><p>$\vec C_{destination}$ ：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。</p><p>$\vec F_{destination}$ ：目标因子值，指定了alpha对目标颜色的影响。</p><p>$\vec F_{source}$ ：源因子值，指定了alpha对源颜色的影响。</p><p>$\vec C_{constant}$ ：常数颜色向量，通过glBlendColor函数来另外设置。</p><ul><li>片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。</li></ul><h4 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h4><ul><li>在混合方程中，对于OpenGL而言，因子值是不知道的，我们将通过glBlendFunc(GLenum sfactor, GLenum dfactor)来设置源和目标因子。</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>值</th></tr></thead><tbody><tr><td>GL_ZERO</td><td>因子等于0</td></tr><tr><td>GL_ONE</td><td>因子等于1</td></tr><tr><td>GL_SRC_COLOR</td><td>因子等于源颜色向量 $\vec C_{source}$</td></tr><tr><td>GL_ONE_MINUS_SRC_COLOR</td><td>因子等于1− $\vec C_{source}$</td></tr><tr><td>GL_DST_COLOR</td><td>因子等于目标颜色向量 $\vec C_{destination}$</td></tr><tr><td>GL_ONE_MINUS_DST_COLOR</td><td>因子等于1− $\vec C_{destination}$</td></tr><tr><td>GL_SRC_ALPHA</td><td>因子等于 $\vec C_{source}$ 的alpha分量</td></tr><tr><td>GL_ONE_MINUS_SRC_ALPHA</td><td>因子等于1− $\vec C_{source}$ 的alpha分量</td></tr><tr><td>GL_DST_ALPHA</td><td>因子等于 $\vec C_{destination}$ 的alpha分量</td></tr><tr><td>GL_ONE_MINUS_DST_ALPHA</td><td>因子等于1− $\vec C_{destination}$ 的alpha分量</td></tr><tr><td>GL_CONSTANT_COLOR</td><td>因子等于常数颜色向量 $\vec C_{constant}$</td></tr><tr><td>GL_ONE_MINUS_CONSTANT_COLOR</td><td>因子等于1− $\vec C_{constant}$</td></tr><tr><td>GL_CONSTANT_ALPHA</td><td>因子等于 $\vec C_{constant}$ 的alpha分量</td></tr><tr><td>GL_ONE_MINUS_CONSTANT_ALPHA</td><td>因子等于1− $\vec C_{constant}$ 的alpha分量</td></tr></tbody></table></div><ul><li>使用使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项：<ul><li>glBlendFuncSeparate(GLenum srcRGB, GLenum destRGB, GLenum srcAlpha, GLenum destAlpha)</li></ul></li><li><p>使用glBlendEquation(GLenum mode)允许我们设置运算符，默认是相加。</p><ul><li>GL<em>FUNC_ADD：默认选项，将两个分量相加： $\vec C</em>{result}$ = Src + Dst</li><li>GL<em>FUNC_SUBTRACT：将两个分量相减： $\vec C</em>{result}$ = Src − Dst</li><li>GL<em>FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反： $\vec C</em>{result}$ = Dst − Src</li></ul></li><li><p>使用混合渲染半透明纹理效果：</p></li><li><img src="/2018/12/23/高级OpenGL（上）/blending_withoutsort.png" alt="使用混合渲染半透明纹理效果"></li><li>可以看到，最前面的窗口挡住了后面的一个窗口，这是由于深度测试与混合一起使用造成的问题。深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。</li><li>在不考虑旋转、缩放或者其它的变换，以及物体形状的情况下，我们通过对物体远近进行排序，逆序渲染，可以得到比较好的效果：</li><li><img src="/2018/12/23/高级OpenGL（上）/blending_withsort.png" alt="使用混合渲染半透明纹理效果"></li></ul><hr><h2 id="面剔除-Face-culling"><a href="#面剔除-Face-culling" class="headerlink" title="面剔除(Face culling)"></a>面剔除(Face culling)</h2><ul><li>对于一个被渲染的物体，我们看不见其背面部分，这部分的渲染其实是没必要的，可以通过面剔除的方法来实现这种想法。</li><li>OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，分析顶点数据的环绕顺序(Winding Order)。</li></ul><h3 id="环绕顺序"><a href="#环绕顺序" class="headerlink" title="环绕顺序"></a>环绕顺序</h3><ul><li>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，我们会从三角形中间来看，为这3个顶点设定一个环绕顺序。</li><li><img src="/2018/12/23/高级OpenGL（上）/faceculling_windingorder.png" alt="三角形顶点环绕顺序"></li><li>每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。</li><li>一般的，面向观察者视角所见的三角形为正向的。</li><li><img src="/2018/12/23/高级OpenGL（上）/faceculling_frontback.png" alt="三角形顶点环绕顺序"></li></ul><h3 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h3><ul><li>OpenGL提供glEnable(GL_CULL_FACE)方法供我们开启面剔除。</li><li>我们还可以通过glCullFace方法来修改要剔除的面的类型：<ul><li>GL_BACK：只剔除背向面。</li><li>GL_FRONT：只剔除正向面。</li><li>GL_FRONT_AND_BACK：剔除正向面和背向面。</li></ul></li><li>OpenGL也提供了glFrontFace方法，供我们设定何种环绕顺序为正向面：<ul><li>GL_CW：顺时针。</li><li>GL_CCW：逆时针。</li></ul></li><li>通过开启面剔除及设置正向面为顺时针方向，我们可以只渲染立方体背面：</li><li><img src="/2018/12/23/高级OpenGL（上）/face_culling.png" alt="面剔除效果"></li></ul><hr><h2 id="帧缓冲-Framebuffers"><a href="#帧缓冲-Framebuffers" class="headerlink" title="帧缓冲(Framebuffers)"></a>帧缓冲(Framebuffers)</h2><ul><li>用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在内存中。OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。</li></ul><h3 id="创建帧缓冲"><a href="#创建帧缓冲" class="headerlink" title="创建帧缓冲"></a>创建帧缓冲</h3><ul><li><p>帧缓冲的创建、使用、销毁步骤如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fbo;<br><span class="hljs-comment">// 创建一个帧缓冲对象(Framebuffer Object, FBO)</span><br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;fbo);<br><span class="hljs-comment">// 绑定帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, fbo);<br><span class="hljs-comment">// 附加缓冲，颜色附件等操作...</span><br>...<br><span class="hljs-comment">// 检查帧缓冲是否完整</span><br>glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE<br><span class="hljs-comment">// 再次激活默认帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 在完成所有的帧缓冲操作之后，删除这个帧缓冲对象</span><br>glDeleteFramebuffers(<span class="hljs-number">1</span>, &amp;fbo);<br></code></pre></td></tr></table></figure></li><li><p>在创建完帧缓冲后，并不能马上进行使用，因为其是不完整的。一个完整的帧缓冲需要满足以下的条件：</p><ul><li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li><li>至少有一个颜色附件(Attachment)。</li><li>所有的附件都必须是完整的（保留了内存）。</li><li>每个缓冲都应该有相同的样本数。</li></ul></li></ul><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><h4 id="为帧缓存创建纹理"><a href="#为帧缓存创建纹理" class="headerlink" title="为帧缓存创建纹理"></a>为帧缓存创建纹理</h4><ul><li><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就想它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> texture;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;texture);<br>glBindTexture(GL_TEXTURE_2D, texture);<br><br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="hljs-literal">NULL</span>);<br><br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure></li><li><p>我们将其大小设置为屏幕大小（非必要，但后面的例子中会直接使用其替换整个窗口屏幕），数据传入NULL。</p></li><li>即，我们仅创建了一片内存，并没有对其进行数据填充。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。</li><li><p>创建完纹理后，我们需要将其附加到帧缓冲上。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>glFrameBufferTexture2D有以下的参数：</p><ul><li>target：帧缓冲的目标（绘制、读取或者两者皆有）</li><li>attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。</li><li>textarget：你希望附加的纹理类型</li><li>texture：要附加的纹理本身</li><li>level：多级渐远纹理的级别。我们将它保留为0。</li></ul></li><li><p>除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为GL_DEPTH_ATTACHMENT。注意纹理的格式(Format)和内部格式(Internalformat)类型将变为GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为GL_STENCIL_ATTACHMENT，并将纹理的格式设定为GL_STENCIL_INDEX。</p></li><li><p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每32位数值将包含24位的深度信息和8位的模板信息。使用GL_DEPTH_STENCIL_ATTACHMENT类型，并配置纹理的格式，让它包含合并的深度和模板值。</p></li><li>将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexImage2D(<br>  GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_DEPTH24_STENCIL8, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="hljs-number">0</span>,<br>  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, <span class="hljs-literal">NULL</span><br>);<br><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h4><ul><li>渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</li><li>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用 <em>glReadPixels</em> 来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。</li><li>因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。</li><li><p>使用渲染缓冲对象：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br><span class="hljs-comment">// 绑定这个渲染缓冲对象</span><br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br><span class="hljs-comment">// 创建一个深度和模板渲染缓冲对象</span><br>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, SCREEN_WIDTH, SCREEN_HEIGHT);<br><span class="hljs-comment">// 附加这个渲染缓冲对象</span><br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br></code></pre></td></tr></table></figure></li><li><p>由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们需要深度和模板值用于测试，但不需要对它们进行采样，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p></li><li>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。</li></ul><h3 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个帧缓冲对象，并绑定它</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> framebuffer;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;framebuffer);<br>glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br><br><span class="hljs-comment">// 生成纹理</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> texColorBuffer;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;texColorBuffer);<br>glBindTexture(GL_TEXTURE_2D, texColorBuffer);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>glBindTexture(GL_TEXTURE_2D, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将它附加到当前绑定的帧缓冲对象</span><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, <span class="hljs-number">0</span>);  <br><br><span class="hljs-comment">// 创建渲染缓冲对象作为深度和模板附件渲染缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);  <br>glBindRenderbuffer(GL_RENDERBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将渲染缓冲对象附加到帧缓冲的深度和模板附件</span><br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br><br><span class="hljs-comment">// 完整性检查</span><br><span class="hljs-keyword">if</span>(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::FRAMEBUFFER:: Framebuffer is not complete!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-comment">// 解绑帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// render loop</span><br><span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window))<br>&#123;<br>  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br>  glClearColor(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">1.0f</span>);<br>  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="hljs-comment">// 我们现在不使用模板缓冲</span><br>  glEnable(GL_DEPTH_TEST);<br>  DrawScene();<br><br>  glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回默认缓冲</span><br>  glClearColor(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<br>  glClear(GL_COLOR_BUFFER_BIT);<br><br>  screenShader.use();<br>  glBindVertexArray(quadVAO);<br>  glDisable(GL_DEPTH_TEST);<br>  glBindTexture(GL_TEXTURE_2D, textureColorbuffer);<br>  glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2018/12/23/高级OpenGL（上）/framebuffers_screen_texture.png" alt="渲染帧缓冲"></li></ul><h3 id="核效果"><a href="#核效果" class="headerlink" title="核效果"></a>核效果</h3><ul><li><p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。我们可以结合它们创建出很有意思的效果。</p></li><li><p>核(Kernel)（或卷积矩阵(Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。</p></li><li>通过核，我们可以实现锐化，边缘检测，模糊等效果。</li><li>下面是核的一个例子：<script type="math/tex; mode=display">\begin{bmatrix} 2 & 2 & 2 \\ 2 & -15 & 2 \\ 2 & 2 & 2 \end{bmatrix}</script></li></ul><blockquote><p>大部分核将所有的权重加起来之后都应该会等于1，如果它们加起来不等于1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。</p></blockquote><ul><li><p>片段着色器实现：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> offset = <span class="hljs-number">1.0</span> / <span class="hljs-number">300.0</span>;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    vec2 offsets[<span class="hljs-number">9</span>] = vec2[](<br>        vec2(-offset,  offset), <span class="hljs-comment">// 左上</span><br>        vec2( <span class="hljs-number">0.0f</span>,    offset), <span class="hljs-comment">// 正上</span><br>        vec2( offset,  offset), <span class="hljs-comment">// 右上</span><br>        vec2(-offset,  <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 左</span><br>        vec2( <span class="hljs-number">0.0f</span>,    <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 中</span><br>        vec2( offset,  <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 右</span><br>        vec2(-offset, -offset), <span class="hljs-comment">// 左下</span><br>        vec2( <span class="hljs-number">0.0f</span>,   -offset), <span class="hljs-comment">// 正下</span><br>        vec2( offset, -offset)  <span class="hljs-comment">// 右下</span><br>    );<br><br>    <span class="hljs-keyword">float</span> kernel[<span class="hljs-number">9</span>] = <span class="hljs-keyword">float</span>[](<br>        <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<br>        <span class="hljs-number">-1</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">-1</span>,<br>        <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br>    );<br><br>    vec3 sampleTex[<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>    &#123;<br>        sampleTex[i] = vec3(texture(screenTexture, TexCoords.st + offsets[i]));<br>    &#125;<br>    vec3 col = vec3(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>        col += sampleTex[i] * kernel[i];<br><br>    FragColor = vec4(col, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>边缘检测的效果：</p></li><li><img src="/2018/12/23/高级OpenGL（上）/kernel.jpg" alt="边缘检测"></li></ul><hr><h2 id="立方体贴图-Cubemaps"><a href="#立方体贴图-Cubemaps" class="headerlink" title="立方体贴图(Cubemaps)"></a>立方体贴图(Cubemaps)</h2><ul><li>简单来说，立方体贴图就是一个包含了6个2D纹理的纹理，每个2D纹理都组成了立方体的一个面。</li></ul><h3 id="创建立方体贴图"><a href="#创建立方体贴图" class="headerlink" title="创建立方体贴图"></a>创建立方体贴图</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> textureID;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;textureID);<br>glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);<br><br><span class="hljs-keyword">int</span> width, height, nrChannels;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data;  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; textures_faces.size(); i++)<br>&#123;<br>    data = stbi_load(textures_faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>    glTexImage2D(<br>        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,<br>        <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data<br>    );<br>&#125;<br><br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br><span class="hljs-comment">//对应的是纹理的第三个维度（和位置的z一样）。我们将环绕方式设置为GL_CLAMP_TO_EDGE，</span><br><span class="hljs-comment">//这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），</span><br><span class="hljs-comment">//所以通过使用GL_CLAMP_TO_EDGE，OpenGL将在我们对两个面之间采样的时候，永远返回它们的边界值。</span><br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);<br></code></pre></td></tr></table></figure><ul><li>因为立方体贴图包含有6个纹理，每个面一个，我们需要调用glTexImage2D函数6次，其第一个参数是纹理目标，是从GL_TEXTURE_CUBE_MAP_POSITIVE_X开始线性+1递增的枚举值：</li></ul><div class="table-container"><table><thead><tr><th>纹理目标</th><th>方位</th></tr></thead><tbody><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_X</td><td>右</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</td><td>左</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</td><td>上</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</td><td>下</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</td><td>后</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</td><td>前</td></tr></tbody></table></div><ul><li><p>在绘制使用立方体贴图的物体之前，我们要先激活对应的纹理单元，并绑定立方体贴图。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glActiveTexture(GL_TEXTURE0);<br>glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);<br></code></pre></td></tr></table></figure></li><li><p>在片段着色器中进行采样时，我们会使用vec3而不再是vec2，毕竟是个三维盒子，采样器也改为了samplerCube。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">in vec3 textureDir; <span class="hljs-comment">// 代表3D纹理坐标的方向向量</span><br>uniform samplerCube cubemap; <span class="hljs-comment">// 立方体贴图的纹理采样器</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    FragColor = texture(cubemap, textureDir);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><ul><li>天空盒是一个包含了整个场景的（大）立方体，它包含周围环境的6个图像，让玩家以为他处在一个比实际大得多的环境当中。游戏中使用天空盒的例子有群山、白云或星空。</li><li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_skybox.png" alt="天空盒"></li></ul><h4 id="加载天空盒"><a href="#加载天空盒" class="headerlink" title="加载天空盒"></a>加载天空盒</h4><ul><li>加载天空盒的本质是创建6个图像的纹理过程，具体代码如下：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; faces;<br>&#123;<br>    <span class="hljs-string">"right.jpg"</span>,<br>    <span class="hljs-string">"left.jpg"</span>,<br>    <span class="hljs-string">"top.jpg"</span>,<br>    <span class="hljs-string">"bottom.jpg"</span>,<br>    <span class="hljs-string">"front.jpg"</span>,<br>    <span class="hljs-string">"back.jpg"</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadCubemap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; faces)</span><br></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> textureID;<br>    glGenTextures(<span class="hljs-number">1</span>, &amp;textureID);<br>    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);<br><br>    <span class="hljs-keyword">int</span> width, height, nrChannels;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; faces.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* data = stbi_load(faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (data)<br>        &#123;<br>            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,<br>                         <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data<br>            );<br>            stbi_image_free(data);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cubemap texture failed to load at path: "</span> &lt;&lt; faces[i] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>            stbi_image_free(data);<br>        &#125;<br>    &#125;<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);<br><br>    <span class="hljs-keyword">return</span> textureID;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="显示天空盒"><a href="#显示天空盒" class="headerlink" title="显示天空盒"></a>显示天空盒</h4><ul><li>当我们把天空盒的原点放置在(0, 0, 0)上时，它的每一个位置向量都是从原点出发的方向向量。这个方向向量正是获取立方体上特定位置的纹理值所需要的。正是因为这个，我们只需要提供位置向量而不用纹理坐标了。</li><li>绘制天空盒时，我们可以首先对其进行，并且禁用深度写入。这样子天空盒就会永远被绘制在其它物体的背后了。但是这样的处理方式带来的消耗也是明显的，整个屏幕会被绘制一遍天空盒，会存在大量overdraw的情况。</li><li>之所以先绘制天空盒，再绘制场景中的其他物体，是因为什么想要保证天空盒必然出现在任何其他物体背后，如果我们能通过某种方式，将天空盒的深度值设置为恒大于场景中的其他物体，那么便不需要优先绘制天空盒，相反，我们可以在最后绘制，只绘制其通过深度测试的部分。</li><li>透视除法是在顶点着色器运行之后执行的，将gl_Position的xyz坐标除以w分量。我们又从深度测试小节中知道，相除结果的z分量等于顶点的深度值。使用这些信息，我们可以将输出位置的z分量等于它的w分量，让z分量永远等于1.0，这样子的话，当透视除法执行之后，z分量会变为w / w = 1.0。</li><li><p>故顶点着色器的代码便是：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    TexCoords = aPos;<br>    vec4 pos = projection * view * vec4(aPos, <span class="hljs-number">1.0</span>);<br>    gl_Position = pos.xyww;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们还要改变一下深度函数，将它从默认的GL_LESS改为GL_LEQUAL。深度缓冲将会填充上天空盒的1.0值，所以我们需要保证天空盒在值小于或等于深度缓冲而不是小于时通过深度测试。</p></li></ul><h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><ul><li>使用环境立方体贴图的技术叫做环境映射(Environment Mapping)，其中最流行的两个是反射(Reflection)和折射(Refraction)。</li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul><li>反射这个属性表现为物体（或物体的一部分）反射它周围环境，即根据观察者的视角，物体的颜色或多或少等于它的环境。镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</li><li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_reflection_theory.png" alt="反射"></li><li><p>我们根据观察方向向量 $\vec I$ 和物体的法向量 $\vec N$ ，来计算反射向量 $\vec R$ 。我们可以使用GLSL内建的reflect函数来计算这个反射向量。最终的 $\vec R$ 向量将会作为索引/采样立方体贴图的方向向量，返回环境的颜色值。最终的结果是物体看起来反射了天空盒。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec3 Normal;<br>in vec3 Position;<br><br>uniform vec3 cameraPos;<br>uniform samplerCube skybox;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    vec3 I = normalize(Position - cameraPos);<br>    vec3 R = reflect(I, normalize(Normal));<br>    FragColor = vec4(texture(skybox, R).rgb, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/23/高级OpenGL（上）/reflection.png" alt="反射"></p></li></ul><h4 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h4><ul><li>折射是光线由于传播介质的改变而产生的方向变化。</li><li>折射是通过<a href="https://en.wikipedia.org/wiki/Snell%27s_law" target="_blank" rel="noopener">斯涅尔定律(Snell’s Law)</a>来描述的，使用环境贴图的话看起来像是这样：</li><li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_refraction_theory.png" alt="折射"></li><li>折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。</li><li>折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到：</li></ul><div class="table-container"><table><thead><tr><th>材质</th><th>折射率</th></tr></thead><tbody><tr><td>空气</td><td>1.00</td></tr><tr><td>水</td><td>1.33</td></tr><tr><td>冰</td><td>1.309</td></tr><tr><td>玻璃</td><td>1.52</td></tr><tr><td>钻石</td><td>2.42</td></tr></tbody></table></div><ul><li><p>假设场景中的物体为玻璃材质，则：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    <span class="hljs-keyword">float</span> ratio = <span class="hljs-number">1.00</span> / <span class="hljs-number">1.52</span>;<br>    vec3 I = normalize(Position - cameraPos);<br>    vec3 R = refract(I, normalize(Normal), ratio);<br>    FragColor = vec4(texture(skybox, R).rgb, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/23/高级OpenGL（上）/refraction.png" alt="折射"></p></li></ul><h3 id="环境动态贴图"><a href="#环境动态贴图" class="headerlink" title="环境动态贴图"></a>环境动态贴图</h3><ul><li>前面的反射和折射均是建立在场景中只有一个物体的情况下实现的，但场景中有多个物体时，一个物体的反射/折射会受到其他物体的影响，而上面的实现只是从天空盒中进行采样，没有考虑其他物体对环境的影响。</li><li><p><img src="/2018/12/23/高级OpenGL（上）/double_man.png" alt="多个物体的反射"></p></li><li><p>通过使用帧缓冲，我们能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做动态环境映射(Dynamic Environment Mapping)，因为我们动态创建了物体周围的立方体贴图，并将其用作环境贴图。</p></li><li><p>虽然它看起来很棒，但它有一个很大的缺点：我们需要为使用环境贴图的物体渲染场景6次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p></li><li><p>尚未进行实现。。。。</p></li></ul><h3 id="使用漫反射贴图-反射贴图的效果"><a href="#使用漫反射贴图-反射贴图的效果" class="headerlink" title="使用漫反射贴图+反射贴图的效果"></a>使用漫反射贴图+反射贴图的效果</h3><ul><li><img src="/2018/12/23/高级OpenGL（上）/combine.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 高级OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模型加载</title>
      <link href="/2018/12/10/%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/12/10/%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 模型加载学习笔记</p><p>Assimp，网格，模型。</p></blockquote><a id="more"></a><h2 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h2><ul><li>利用Assimp库，将3D艺术家利用3D建模工具生成的3D模型载入到程序中，转换为我们所熟知的通用数据结构，再将这些数据结构转换为我们代码中自定义的数据结构，然后传给OpenGL，让其能正确渲染出来的过程。</li></ul><h2 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h2><ul><li>3D艺术家们可能会用多种3D建模工具（如Blender，3DS Max，Maya）来构建3D模型，<em>Assimp</em> 能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中。当Assimp加载完模型之后，我们就能够从Assimp的数据结构中提取我们所需的所有数据了。由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。</li><li>Wavefront的模型格式：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">格式均以标识字符串开头，后面紧接着数据。<br># List of geometric vertices, with (x, y, z [,w]) coordinates, w is optional and defaults to 1.0.<br>v 0.123 0.234 0.345 1.0<br>v ...<br>...<br># List of texture coordinates, in (u, v [,w]) coordinates, these will vary between 0 and 1, w is optional and defaults to 0.<br>vt 0.500 1 [0]<br>vt ...<br>...<br># List of vertex normals in (x,y,z) form; normals might not be unit vectors.<br>vn 0.707 0.000 0.707<br>vn ...<br>...<br># Parameter space vertices in ( u [,v] [,w] ) form; free form geometry statement ( see below )<br>vp 0.310000 3.210000 2.100000<br>vp ...<br>...<br># Polygonal face element (see below)<br># Vertex indices/Vertex texture coordinate indices/Vertex normal indices<br># f v1/vt1/vn1<br>f 1 2 3<br>f 3/1 4/2 5/3<br>f 6/4/1 3/5/3 7/6/5<br>f 7//1 8//2 9//3<br>f ...<br>...<br># Line element (see below)<br>l 5 8 1 2 4 9<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2018/12/10/模型加载/assimp_structure.png" alt="Assimp数据结构（简化）"></p><ul><li>和材质和网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</li><li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</li><li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</li><li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的。</li><li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</li></ul><h2 id="网格-Mesh"><a href="#网格-Mesh" class="headerlink" title="网格(Mesh )"></a>网格(Mesh )</h2><ul><li>当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型/形状组合而成。组合模型的每个单独的形状就叫做一个网格(Mesh)。比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。一个网格是我们在OpenGL中绘制物体所需的最小单位（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>通过网格需要能渲染出物体，故网格所需的数据有：<ol><li>位置向量。</li><li>法向量。</li><li>纹理坐标向量。</li><li>用于索引绘制的索引。</li><li>纹理形式的材质数据（漫反射/镜面光贴图）。</li></ol></li><li><p>故，一个网格类将会是这样的结构：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mesh</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 网格数据</span><br>        <span class="hljs-built_in">vector</span>&lt;vec3&gt; Position;<br>        <span class="hljs-built_in">vector</span>&lt;vec3&gt; Normal;<br>        <span class="hljs-built_in">vector</span>&lt;vec2&gt; TexCoords;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices;<br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>将位置向量，法向量，纹理坐标向量合并为顶点结构体，纹理则需要存储纹理id及类型（漫反射贴图、镜面反射贴图）：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span> &#123;</span><br>    glm::vec3 Position;<br>    glm::vec3 Normal;<br>    glm::vec2 TexCoords;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Texture</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-built_in">string</span> type;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><p>通过网格的数据结构，其初始化便是需要传入其所需数据，于是其构造函数便是：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Mesh(<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices, <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;vertices = vertices;<br>    <span class="hljs-keyword">this</span>-&gt;indices = indices;<br>    <span class="hljs-keyword">this</span>-&gt;textures = textures;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>紧随着传入所需数据，我们需要将数据告知OpenGL如何解析，即我们需要配置缓冲及顶点着色器的布局。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">Mesh(<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices, <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;vertices = vertices;<br>    <span class="hljs-keyword">this</span>-&gt;indices = indices;<br>    <span class="hljs-keyword">this</span>-&gt;textures = textures;<br><br>    setupMesh();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupMesh</span><span class="hljs-params">()</span><br></span>&#123;<br>    glGenVertexArrays(<span class="hljs-number">1</span>, &amp;VAO);<br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;VBO);<br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;EBO);<br><br>    glBindVertexArray(VAO);<br>    glBindBuffer(GL_ARRAY_BUFFER, VBO);<br><br>    glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="hljs-keyword">sizeof</span>(Vertex), &amp;vertices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);  <br><br>    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>),<br>                 &amp;indices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 顶点位置</span><br>    glEnableVertexAttribArray(<span class="hljs-number">0</span>);   <br>    glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(Vertex), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 顶点法线</span><br>    glEnableVertexAttribArray(<span class="hljs-number">1</span>);   <br>    glVertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(Vertex), (<span class="hljs-keyword">void</span>*)offsetof(Vertex, Normal));<br>    <span class="hljs-comment">// 顶点纹理坐标</span><br>    glEnableVertexAttribArray(<span class="hljs-number">2</span>);   <br>    glVertexAttribPointer(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(Vertex), (<span class="hljs-keyword">void</span>*)offsetof(Vertex, TexCoords));<br><br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><ul><li><p>通过规范命名的方式，即如每个漫反射纹理被命名为 <em>texture_diffuseN</em>，每个镜面光纹理应该被命名为 <em>texture_specularN</em>，其中N的范围是1到纹理采样器最大允许的数字。比如说我们对某一个网格有3个漫反射纹理，2个镜面光纹理，它们的纹理采样器应该之后会被调用：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">uniform sampler2D texture_diffuse1;<br>uniform sampler2D texture_diffuse2;<br>uniform sampler2D texture_diffuse3;<br>uniform sampler2D texture_specular1;<br>uniform sampler2D texture_specular2;<br></code></pre></td></tr></table></figure></li><li><p>进行纹理绑定之后，我们只需要调用glDrawElements即可进行绘制。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">(Shader shader)</span><br></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> diffuseNr = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> specularNr = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; textures.size(); i++)<br>    &#123;<br>        glActiveTexture(GL_TEXTURE0 + i); <span class="hljs-comment">// 在绑定之前激活相应的纹理单元</span><br>        <span class="hljs-comment">// 获取纹理序号（diffuse_textureN 中的 N）</span><br>        <span class="hljs-built_in">string</span> number;<br>        <span class="hljs-built_in">string</span> name = textures[i].type;<br>        <span class="hljs-keyword">if</span>(name == <span class="hljs-string">"texture_diffuse"</span>)<br>            number = <span class="hljs-built_in">std</span>::to_string(diffuseNr++);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name == <span class="hljs-string">"texture_specular"</span>)<br>            number = <span class="hljs-built_in">std</span>::to_string(specularNr++);<br><br>        shader.setInt((name + number).c_str(), i);<br>        glBindTexture(GL_TEXTURE_2D, textures[i].id);<br>    &#125;<br>    glActiveTexture(GL_TEXTURE0);<br><br>    <span class="hljs-comment">// 绘制网格</span><br>    glBindVertexArray(VAO);<br>    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="模型-model"><a href="#模型-model" class="headerlink" title="模型(model)"></a>模型(model)</h2><ul><li>一个模型包含多个网格，通过对模型中所有网格的绘制，从而将模型整体展现出来。</li></ul><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>一个模型包含多个网格。</li><li>一般而言，网格中的纹理贴图等文件均为相对于模型路径的相对路径。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span><br>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">//  模型数据</span><br>        <span class="hljs-built_in">vector</span>&lt;Mesh&gt; meshes;<br>        <span class="hljs-built_in">string</span> directory;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><ul><li>通过指定的模型路径对模型进行加载。</li><li>在模型载入中，由于Assimp数据结构是树形结构，故需要一个递归便利node的函数。</li><li>需要一个将Assimp中的Mesh数据解析成我们程序中的Mesh结构体的方法。</li><li><p>于是Model类变为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span><br>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">//  函数</span><br>        Model(<span class="hljs-keyword">char</span>* path)<br>        &#123;<br>            loadModel(path);<br>        &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">//  模型数据</span><br>        <span class="hljs-built_in">vector</span>&lt;Mesh&gt; meshes;<br>        <span class="hljs-built_in">string</span> directory;<br>        <span class="hljs-comment">//  函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">(<span class="hljs-built_in">string</span> path)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processNode</span><span class="hljs-params">(aiNode* node, <span class="hljs-keyword">const</span> aiScene* scene)</span></span>;<br>        <span class="hljs-function">Mesh <span class="hljs-title">processMesh</span><span class="hljs-params">(aiMesh* mesh, <span class="hljs-keyword">const</span> aiScene* scene)</span></span>;<br>        <span class="hljs-comment">// 方便材质处理</span><br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; loadMaterialTextures(aiMaterial* mat, aiTextureType type, <span class="hljs-built_in">string</span> typeName);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>loadModel方法对指定路径的文件进行加载，然后调用递归遍历Node的方法。</p></li><li><p>将Assimp网格数据转换为网格结构体也可以在此函数中通过遍历所有Assimp数据然后生成meshes。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">(<span class="hljs-built_in">string</span> path)</span><br></span>&#123;<br>    Assimp::Importer <span class="hljs-keyword">import</span>;<br>    <span class="hljs-keyword">const</span> aiScene* scene = <span class="hljs-keyword">import</span>.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);    <br><br>    <span class="hljs-keyword">if</span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::ASSIMP::"</span> &lt;&lt; <span class="hljs-keyword">import</span>.GetErrorString() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    directory = path.substr(<span class="hljs-number">0</span>, path.find_last_of(<span class="hljs-string">'/'</span>));<br><br>    processNode(scene-&gt;mRootNode, scene);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>processNode方法先遍历所有网格索引以生成网格数据，再遍历子Node。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processNode</span><span class="hljs-params">(aiNode* node, <span class="hljs-keyword">const</span> aiScene* scene)</span><br></span>&#123;<br>    <span class="hljs-comment">// 处理节点所有的网格（如果有的话）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;mNumMeshes; i++)<br>    &#123;<br>        aiMesh* mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]];<br>        meshes.push_back(processMesh(mesh, scene));         <br>    &#125;<br>    <span class="hljs-comment">// 接下来对它的子节点重复这一过程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;mNumChildren; i++)<br>    &#123;<br>        processNode(node-&gt;mChildren[i], scene);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>processMesh将mesh-&gt;mNumVertices转换成顶点数据，mesh0&gt;mNumFaces转换成顶点索引使用数据，最后再通过GetTextureCount方法获取每种具体材质的数量来生成具体材质。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Mesh <span class="hljs-title">processMesh</span><span class="hljs-params">(aiMesh *mesh, <span class="hljs-keyword">const</span> aiScene *scene)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices;<br>    <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mesh-&gt;mNumVertices; i++)<br>    &#123;<br>        Vertex vertex;<br>        <span class="hljs-comment">// 处理顶点位置、法线和纹理坐标</span><br>        glm::vec3 <span class="hljs-built_in">vector</span>;<br>        <span class="hljs-built_in">vector</span>.x = mesh-&gt;mVertices[i].x;<br>        <span class="hljs-built_in">vector</span>.y = mesh-&gt;mVertices[i].y;<br>        <span class="hljs-built_in">vector</span>.z = mesh-&gt;mVertices[i].z;<br>        vertex.Position = <span class="hljs-built_in">vector</span>;<br>        ...<br>        vertices.push_back(vertex);<br>    &#125;<br><br>    <span class="hljs-comment">// faces 处理索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mesh-&gt;mNumFaces; ++i) &#123;<br>        aiFace face = mesh-&gt;mFaces[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; face.mNumIndices; ++j) &#123;<br>          indices.push_back(face.mIndices[j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// materials 处理材质</span><br>    <span class="hljs-keyword">if</span> (mesh-&gt;mMaterialIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        aiMaterial* material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];<br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, <span class="hljs-string">"texture_diffuse"</span>);<br>        textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());<br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, <span class="hljs-string">"texture_specular"</span>);<br>        textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());<br>        <span class="hljs-comment">// 3. normal maps</span><br>        <span class="hljs-comment">//std::vector&lt;Texture&gt; normalMaps = loadMaterialTextures(material, aiTextureType_HEIGHT, "texture_normal");</span><br>        <span class="hljs-comment">//textures.insert(textures.end(), normalMaps.begin(), normalMaps.end());</span><br>        <span class="hljs-comment">// 4. height maps</span><br>        <span class="hljs-comment">//std::vector&lt;Texture&gt; heightMaps = loadMaterialTextures(material, aiTextureType_AMBIENT, "texture_height");</span><br>        <span class="hljs-comment">//textures.insert(textures.end(), heightMaps.begin(), heightMaps.end());</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Mesh(vertices, indices, textures);<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, <span class="hljs-built_in">string</span> typeName)<br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat-&gt;GetTextureCount(type); i++)<br>    &#123;<br>        aiString str;<br>        mat-&gt;GetTexture(type, i, &amp;str);<br>        Texture texture;<br>        texture.id = TextureFromFile(str.C_Str(), directory);<br>        texture.type = typeName;<br>        texture.path = str;<br>        textures.push_back(texture);<br>    &#125;<br>    <span class="hljs-keyword">return</span> textures;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>Assimp加载模型加入聚光后的效果。</li><li><img src="/2018/12/10/模型加载/效果图.png" alt="Assimp加载模型效果图"></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 模型加载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>光照</title>
      <link href="/2018/12/08/%E5%85%89%E7%85%A7/"/>
      <url>/2018/12/08/%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 光照学习笔记</p><p>颜色、基础光照、材质、光照贴图、投光物体、多光源。</p></blockquote><a id="more"></a><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li><p>颜色，即物体不要的颜色，即光照于其上，不被吸收的剩余部分，一般用三维向量来表示物体从一个光源反射各个颜色分量的大小，通过点乘容易得出物体被通过光反射后的颜色。</p><blockquote><p>如红光照射于物品上，其上红色被过滤了一半：<br>$dot(lightColor(1.0f, 0.0f, 0.0f),itemColor(0.5f, 0.5f, 0.31f))$<br>= $resultColor(0.5f, 0.0f, 0.0f)$</p><p>所以，光照显示的颜色最朴素的表示便是光照颜色点乘物品颜色。</p></blockquote></li></ul><hr><h2 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h2><h3 id="冯氏光照模型-Phong-Lighting-Model"><a href="#冯氏光照模型-Phong-Lighting-Model" class="headerlink" title="冯氏光照模型(Phong Lighting Model)"></a>冯氏光照模型(Phong Lighting Model)</h3><ul><li><p>物品由三部分光照分量组成，分别为：</p><ol><li>环境光(Ambient)<ul><li>即使在很黑暗的情况下，依稀有的一点点光亮，宛如黑夜中摸黑看见物体的轮廓。</li></ul></li><li>漫反射光(Diffuse)<ul><li>用于模拟方向性影响(Directional Imapct)，即越被光照到的地方（越是正对着光照）会越清晰。</li></ul></li><li>镜面光(Specular)<ul><li>就像杯子上的釉质，当光照射的时候会形成反光亮点，该亮点更倾向于光的颜色。即如黑色杯子反射出白色的反光亮点。</li></ul></li></ol><p><img src="/2018/12/08/光照/basic_lighting_phong.png" alt="冯氏光照模型"></p></li></ul><h3 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h3><ul><li>我们所处的世界不止一个光源，所看见的物品的颜色也不是由一个光源产生的结果，且物品会反射光照，从而对其他物品造成间接影响。考虑到这种情况的算法叫做<strong>全局光照</strong>，这种算法开销很大，而环境光照则是一种简化版，用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。</li></ul><h3 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h3><p>  <img src="/2018/12/08/光照/diffuse_light.png" alt=""></p><ul><li>法向量(Normal Vector)：垂直于片段表面的向量，一般会将之单位化，通过叉乘得出顶点的法向量。</li><li>定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li><li>通过法向量与定向的光线，我们容易通过余弦定理计算出其夹角，两者夹角越大，光照对其产生的漫反射影响越小。在实践中，我们通过计算两者单位化后的余弦值来替代夹角以减少运算量。至于其能替代的原因，一方面因为两者正相关，另外一方面，我认为是余弦函数的表现与实际情况更相符，显示中在夹角趋于90度时，物体反射光照不是线性减弱，其趋于0度时亦然。</li><li>注意：<ol><li>片段着色器里的计算都是在世界空间坐标中进行的。所以，法向量也需要转换为世界空间坐标。</li><li>法向量不代表空间中的特定位置，没有齐次坐标（顶点位置中的w分量），即位移不应该影响到法向量。如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3×3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移，目前的学习中采用此种方式）。对于法向量，我们只希望对它实施缩放和旋转变换。</li><li>如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。\<br><img src="/2018/12/08/光照/normalvec.png" alt="缩放前后向量"></li><li>我们通过<strong>法线矩阵</strong>来解决不等比缩放问题，在顶点着色器中，我们可以通过下面的方式来计算获得法线矩阵。（对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。在绘制之前你最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。）\<br>mat3(transpose(inverse(model)))</li><li>法线矩阵推导（利用缩放前后均垂直于切线的特性证明。）（参考<a href="http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix" target="_blank" rel="noopener">http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix</a>）：<script type="math/tex; mode=display">T = P_{2} - P_{1}</script><script type="math/tex; mode=display">T * Modelview = (P_{2} - P_{1}) * Modelview</script><script type="math/tex; mode=display">T * Modelview = P_{2} * Modelview - P_{1} * Modelview</script><script type="math/tex; mode=display">T^{'} = P_{2}^{'} - P_{1}^{'}</script><script type="math/tex; mode=display">N = Q_{2} - Q_{1}</script><script type="math/tex; mode=display">设G为缩放后正确的3X3矩阵，M为模型矩阵左上角的3X3部分。</script><script type="math/tex; mode=display">N^{'}·T^{'} = (GN)·(MT) = 0</script><script type="math/tex; mode=display">(GN)·(MT) = (GN)^{T} * (MT)</script><script type="math/tex; mode=display">(GN)^{T} * (MT) = N^{T}G^{T}MT</script><script type="math/tex; mode=display">假设G^{T}M = I，那么上式变为N^{T}T</script><script type="math/tex; mode=display">于是有N^{'}·T^{'} = N·T = 0</script><script type="math/tex; mode=display">于是得出G</script><script type="math/tex; mode=display">G^{T}M = I \Longrightarrow G = (M^{-1})^{T}</script><script type="math/tex; mode=display">模型矩阵左上角的逆矩阵的转置矩阵</script></li></ol></li></ul><h3 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h3><p>  <img src="/2018/12/08/光照/basic_lighting_specular_theory.png" alt=""></p><ul><li>通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</li><li>观察向量：通过观察者在世界空间位置和片段的位置来计算获得。（若希望在观察空间进行光照计算，所有相关的向量都要用观察矩阵进行变换，法线矩阵也需要进行变换。在观察空间进行光照计算的好处是观察者的位置总是(0, 0, 0)，所以这样你直接就获得了观察者位置。）</li><li>反射向量：与入射向量关于法向量成镜像但方向相反，在片段着色器中，我们可以通过reflect函数求得反射向量。reflect要求第一个向量是从光源指向片段位置的向量。vec3 reflectDir = reflect(-lightDir, norm)</li><li>反光度(Shininess)：一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。\<br><img src="/2018/12/08/光照/basic_lighting_specular_shininess.png" alt=""></li><li>镜面分量计算：<br>$float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);$</li></ul><h3 id="Gouraud着色-Gouraud-Shading"><a href="#Gouraud着色-Gouraud-Shading" class="headerlink" title="Gouraud着色(Gouraud Shading)"></a>Gouraud着色(Gouraud Shading)</h3><ul><li>在光照着色器的早期，开发者曾经在顶点着色器中实现冯氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以（开销大的）光照计算频率会更低。然而，顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。</li><li>目前在雾气的实现中有使用到Gouraud着色。\<br><img src="/2018/12/08/光照/basic_lighting_gouruad.png" alt=""></li></ul><hr><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li><p>在现实世界里，每个物体会对光产生不同的反应。</p><blockquote><p>比如说，钢看起来通常会比陶瓷花瓶更闪闪发光，木头箱子也不会像钢制箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。如果我们想要在OpenGL中模拟多种类型的物体，我们必须为每个物体分别定义一个材质(Material)属性。</p></blockquote></li><li><p>利用冯氏光照模型，我们通过对物体环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)分别指定一个颜色，再加上反光度(Shininess)来得到物体的材质属性。环境光和漫反射分量一般设置成我们想要让物体所拥有的颜色，镜面分量则设置为RGB相等的值。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Material</span> &#123;</span><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>    <span class="hljs-keyword">float</span> shininess;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>对于光，我们也可以定义光照属性，单独设置光照对物体环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)的影响值。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>    vec3 position;<br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通过光照属性和材质属性的配合，我们能得到更好视觉效果：</p><figure class="hljs highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">vec3 ambient  = light.ambient * material.ambient;<br>vec3 diffuse  = light.diffuse * (diff * material.diffuse);<br>vec3 specular = light.specular * (spec * material.specular);<br></code></pre></td></tr></table></figure><ul><li><img src="/2018/12/08/光照/materials.png" alt=""></li></ul></li></ul><hr><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><ul><li>仅有材质属性是不够的，世界上大多数物体不是一个纯净物状态的整体，如杯子外壁是黑色高反光而内壁则为白色反光性较低。</li></ul><h3 id="漫反射贴图-Diffuse-Map"><a href="#漫反射贴图-Diffuse-Map" class="headerlink" title="漫反射贴图(Diffuse Map)"></a>漫反射贴图(Diffuse Map)</h3><ul><li>与纹理用于获取片段在物体具体位置上的颜色相似，在光照场景中，我们用相同的方式来获取其漫反射颜色，这种纹理被叫做漫反射贴图。</li></ul><h3 id="镜面光贴图-Specular-Map"><a href="#镜面光贴图-Specular-Map" class="headerlink" title="镜面光贴图(Specular Map)"></a>镜面光贴图(Specular Map)</h3><ul><li>与漫反射贴图相同，对于镜面光我们也需要从纹理中采集，便有了镜面光贴图。</li><li>从现实角度来说，镜面高光的颜色大部分（甚至全部）都是由光源本身所决定的，所以这样并不能生成非常真实的视觉效果（这也是为什么图像通常是黑白的，我们只关心强度）。</li><li><p>增加了漫反射贴图和镜面反射贴图后，材质的数据结构改为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Material</span> &#123;</span><br>    sampler2D diffuse;<br>    sampler2D specular;<br>    <span class="hljs-keyword">float</span>     shininess;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>片段着色器中代码改为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));<br>vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));  <br>vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));<br>FragColor = vec4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="放射光贴图-Emission-Map"><a href="#放射光贴图-Emission-Map" class="headerlink" title="放射光贴图(Emission Map)"></a>放射光贴图(Emission Map)</h3><ul><li><p>对于想让物体自发光的情况，如黑暗房间中看见一个发光的箱子等，可以通过放射光贴图实现。在片段着色器生成最终颜色时加上采样放射光贴图上的颜色，以达到忽略光照条件进行发光的效果。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">vec3 result = ambient  + diffuse + specular + vec3(texture(material.emission, TexCoord));<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/lightingmaps.png" alt=""></p></li></ul><hr><h2 id="投光物-Light-Caster"><a href="#投光物-Light-Caster" class="headerlink" title="投光物(Light Caster)"></a>投光物(Light Caster)</h2><ul><li>将光投射(Cast)到物体的光源叫做投光物(Light Caster)。</li></ul><h3 id="定向光-Directional-Light"><a href="#定向光-Directional-Light" class="headerlink" title="定向光(Directional Light)"></a>定向光(Directional Light)</h3><ul><li>当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。太阳便是定向光的一个好例子。</li><li><img src="/2018/12/08/光照/light_casters_directional.png" alt=""></li><li>定向光的特点：<ul><li>光源位置对定向光无影响。</li><li>光的方向恒定且平行。</li><li>光照强度不会衰减。</li></ul></li><li><p>由于光源的位置对定向光没有影响，而光照方向恒定且平行，所以对于定向光的数据结构为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>    <span class="hljs-comment">// vec3 position; // 使用定向光就不再需要了</span><br>    vec3 direction;  <span class="hljs-comment">// 光射出的方向</span><br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/dir_light.png" alt=""></p></li></ul><h3 id="点光源-Point-Light"><a href="#点光源-Point-Light" class="headerlink" title="点光源(Point Light)"></a>点光源(Point Light)</h3><ul><li>如同现实世界的白炽灯一般，点光源的光从一点发出，发向所有方向，光线随距离增加而衰减。</li><li><img src="/2018/12/08/光照/light_casters_point.png" alt=""></li><li>点光源的特点：<ul><li>光源位置对点光源有影响。</li><li>光从一点发出，发向所有方向。</li><li>光照强度会衰减。</li></ul></li></ul><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><ul><li>随着光线传播距离的增长逐渐削减光的强度通常叫做衰减(Attenuation)。</li><li>衰减方程：<script type="math/tex; mode=display">F_{att} = \frac{1.0}{K_{c} + K_{l} * d + K_{q} * d^2}</script></li><li><p>光照衰减方程的理解：</p><ol><li>为符合先衰减得快，再衰减得慢，所以是距离倒数($\frac{1.0}{d}$)的形式。</li><li>为保证衰减值恒小于等于1，加入常数项 $K_{c}$ 。</li><li>为了加快远距离光的衰减，加入二次项 $K_{q} * d^2$ 。</li></ol></li><li><p>于是对于点光源的结构体便是：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>    vec3 position;  <br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br><br>    <span class="hljs-keyword">float</span> constant;<br>    <span class="hljs-keyword">float</span> linear;<br>    <span class="hljs-keyword">float</span> quadratic;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/point_light.png" alt=""></p></li></ul><h3 id="聚光-Spotlight"><a href="#聚光-Spotlight" class="headerlink" title="聚光(Spotlight)"></a>聚光(Spotlight)</h3><ul><li>只朝特定方向而不是所有方向发射光线，如现实世界中的手电筒。</li><li>OpenGL中聚光是用一个世界空间位置、一个方向和一个切光角(Cutoff Angle)来表示的，切光角指定了聚光的半径。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。</li><li><img src="/2018/12/08/光照/light_casters_spotlight_angles.png" alt=""></li><li>LightDir：从片段指向光源的向量。</li><li>SpotDir：聚光所指向的方向。</li><li>Phiϕ：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li><li>Thetaθ：LightDir向量和SpotDir向量之间的夹角。在聚光内部的话θ值应该比ϕ值小。</li><li>在实际运算中，我们用LightDir和SpotDir的点积与切光角ϕ的余弦值比较大小来替代角度大小比较，以减少计算量。</li></ul><h3 id="平滑边缘"><a href="#平滑边缘" class="headerlink" title="平滑边缘"></a>平滑边缘</h3><ul><li>用上面的方式创造出来的聚光的边缘界限会很明显，与现实不相符。</li><li><img src="/2018/12/08/光照/spot_light1.png" alt=""></li><li>通过设置内圆锥(Inner Cone)和外圆锥(Outer Cone)的方式，对于落在内圆锥外及外圆锥内的光，让其光照从内圆锥逐渐向外圆锥减少至0。</li><li><p>使用的递减公式为：</p><script type="math/tex; mode=display">I= \frac{\theta - \gamma}{\epsilon}</script><blockquote><p>这里ϵ(Epsilon)是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ=ϕ−γ）。最终的I值就是在当前片段聚光的强度。</p></blockquote></li><li><p>聚光的特点：</p><ul><li>光源位置对聚光有影响。</li><li>光从一点发出，发向指定方向，即光被聚集在一个范围内。</li></ul></li><li><p>对于聚光的结构体为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>vec3 position;<br>  vec3 direction;<br><span class="hljs-keyword">float</span> cutOff;<br><span class="hljs-keyword">float</span> outerCutOff;<br><br>  vec3 ambient;<br>  vec3 diffuse;<br>  vec3 specular;<br><br>  <span class="hljs-comment">// float constant;</span><br>  <span class="hljs-comment">// float linear;</span><br>  <span class="hljs-comment">// float quadratic;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/spot_light2.png" alt=""></p></li><li><p>最终计算聚光的片段着色器代码为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 环境光</span><br>vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoord));<br>vec3 diffuse = vec3(<span class="hljs-number">0</span>);<br>vec3 specular = vec3(<span class="hljs-number">0</span>);<br><br>vec3 norm = normalize(Normal);<br>vec3 lightDir = normalize(light.position - FragPos);<br><span class="hljs-keyword">float</span> theta = dot(lightDir, normalize(-light.direction));<br><span class="hljs-keyword">float</span> epsilon   = light.cutOff - light.outerCutOff;<br><span class="hljs-keyword">float</span> intensity = clamp((theta - light.outerCutOff) / epsilon, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br><br><span class="hljs-keyword">if</span>(theta &gt; light.outerCutOff) &#123;<br><span class="hljs-comment">// 漫反射光</span><br><span class="hljs-keyword">float</span> diff = max(dot(norm, lightDir), <span class="hljs-number">0.0</span>);<br>diffuse = intensity * light.diffuse * diff * vec3(texture(material.diffuse, TexCoord));<br><br><span class="hljs-comment">// 镜面光</span><br>vec3 viewDir = normalize(viewPos - FragPos);<br>vec3 reflectDir = reflect(-lightDir, norm);<br><span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>specular = intensity * light.specular * spec * vec3(texture(material.specular, TexCoord));<br>&#125;<br><br>vec3 result = ambient  + diffuse + specular;<br>FragColor = vec4(result, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="多光源-Multiple-lights"><a href="#多光源-Multiple-lights" class="headerlink" title="多光源(Multiple lights)"></a>多光源(Multiple lights)</h2><ul><li>将冯氏着色(Phong Shading)、材质(Material)、光照贴图(Lighting Map)以及不同种类的投光物(Light Caster)等零碎知识都放于同一场景中。</li><li>对光照的计算将会变成下面的样式：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">out vec4 FragColor;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>  <span class="hljs-comment">// 定义一个输出颜色值</span><br>  vec3 output;<br>  <span class="hljs-comment">// 将定向光的贡献加到输出中</span><br>  output += someFunctionToCalculateDirectionalLight();<br>  <span class="hljs-comment">// 对所有的点光源也做相同的事情</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nr_of_point_lights; i++)<br>    output += someFunctionToCalculatePointLight();<br>  <span class="hljs-comment">// 也加上其它的光源（比如聚光）</span><br>  output += someFunctionToCalculateSpotLight();<br><br>  FragColor = vec4(output, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定向光"><a href="#定向光" class="headerlink" title="定向光"></a>定向光</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DirLight</span> &#123;</span><br>    vec3 direction;<br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;  <br>uniform DirLight dirLight;<br><br><span class="hljs-function">vec3 <span class="hljs-title">CalcDirLight</span><span class="hljs-params">(DirLight light, vec3 normal, vec3 viewDir)</span><br></span>&#123;<br>    vec3 lightDir = normalize(-light.direction);<br>    <span class="hljs-comment">// 漫反射着色</span><br>    <span class="hljs-keyword">float</span> diff = max(dot(normal, lightDir), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-comment">// 镜面光着色</span><br>    vec3 reflectDir = reflect(-lightDir, normal);<br>    <span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>    <span class="hljs-comment">// 合并结果</span><br>    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));<br>    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));<br>    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));<br>    <span class="hljs-keyword">return</span> (ambient + diffuse + specular);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PointLight</span> &#123;</span><br>    vec3 position;<br><br>    <span class="hljs-keyword">float</span> constant;<br>    <span class="hljs-keyword">float</span> linear;<br>    <span class="hljs-keyword">float</span> quadratic;<br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;  <br><br><span class="hljs-function">vec3 <span class="hljs-title">CalcPointLight</span><span class="hljs-params">(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)</span><br></span>&#123;<br>    vec3 lightDir = normalize(light.position - fragPos);<br>    <span class="hljs-comment">// 漫反射着色</span><br>    <span class="hljs-keyword">float</span> diff = max(dot(normal, lightDir), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-comment">// 镜面光着色</span><br>    vec3 reflectDir = reflect(-lightDir, normal);<br>    <span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>    <span class="hljs-comment">// 衰减</span><br>    <span class="hljs-keyword">float</span> distance    = length(light.position - fragPos);<br>    <span class="hljs-keyword">float</span> attenuation = <span class="hljs-number">1.0</span> / (light.constant + light.linear * distance +<br>                 light.quadratic * (distance * distance));    <br>    <span class="hljs-comment">// 合并结果</span><br>    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));<br>    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));<br>    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));<br>    ambient  * = attenuation;<br>    diffuse  * = attenuation;<br>    specular * = attenuation;<br>    <span class="hljs-keyword">return</span> (ambient + diffuse + specular);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="聚光"><a href="#聚光" class="headerlink" title="聚光"></a>聚光</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpotLight</span> &#123;</span><br>vec3 position;<br>vec3 direction;<br><br><span class="hljs-keyword">float</span> cutOff;<br><span class="hljs-keyword">float</span> outerCutOff;<br><br><span class="hljs-keyword">float</span> constant;<br>  <span class="hljs-keyword">float</span> linear;<br>  <span class="hljs-keyword">float</span> quadratic;<br><br>vec3 ambient;<br>  vec3 diffuse;<br>  vec3 specular;<br>&#125;;<br><br><span class="hljs-function">vec3 <span class="hljs-title">CalcSpotLight</span><span class="hljs-params">(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)</span><br></span>&#123;<br><span class="hljs-comment">// 环境光</span><br>  vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoord));<br>vec3 diffuse = vec3(<span class="hljs-number">0</span>);<br>vec3 specular = vec3(<span class="hljs-number">0</span>);<br><br>vec3 lightDir = normalize(light.position - fragPos);<br><span class="hljs-keyword">float</span> theta = dot(lightDir, normalize(-light.direction));<br><span class="hljs-keyword">float</span> epsilon   = light.cutOff - light.outerCutOff;<br><span class="hljs-keyword">float</span> intensity = clamp((theta - light.outerCutOff) / epsilon, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br><br><span class="hljs-keyword">if</span>(theta &gt; light.outerCutOff) &#123;<br><span class="hljs-comment">// 漫反射光</span><br><span class="hljs-keyword">float</span> diff = max(dot(normal, lightDir), <span class="hljs-number">0.0</span>);<br>diffuse = intensity * light.diffuse * diff * vec3(texture(material.diffuse, TexCoord));<br><br><span class="hljs-comment">// 镜面光</span><br>vec3 viewDir = normalize(viewPos - fragPos);<br>vec3 reflectDir = reflect(-lightDir, normal);<br><span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>specular = intensity * light.specular * spec * vec3(texture(material.specular, TexCoord));<br>&#125;<br><br><span class="hljs-keyword">float</span> disition = length(light.position - fragPos);<br><span class="hljs-keyword">float</span> attennuation = <span class="hljs-number">1.0</span> / (light.constant + light.linear * disition + light.quadratic * disition * disition);<br><br>    <span class="hljs-keyword">return</span> attennuation * (ambient  + diffuse + specular);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017随记-1200bookshop</title>
      <link href="/2017/03/12/2017%E9%9A%8F%E8%AE%B0-1200bookshop/"/>
      <url>/2017/03/12/2017%E9%9A%8F%E8%AE%B0-1200bookshop/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/03/12/2017随记-1200bookshop/img1.jpg" style="width: 30em;" alt="书店清晨"></p><a id="more"></a><ul><li>下班后天空飘着细雨，漫步在正佳大街上，看着人来人往，听着伞上的细响，一路走着，我走向书店。</li><li>三楼依旧挤满了人，幸运的是，我在二楼找到座位。</li><li>午夜12点，店里的分享活动开始了，回到三楼，听了约摸一小时的分享，周围回归宁静。在宁静中看完汤川学与石神的较量后，天泛起了亮光。透过玻璃窗隔着雾气看着清静的街道，广州，正在醒来。如同相反一般，我闭上眼睛，揉了揉眼，进入了梦乡。</li><li>在突然变大的音乐声中醒来，因清扫需要，读者们纷纷离开书店。简单梳洗过后，我在楼下吃过早餐，又回到店中。之后便是阅读，觅食，阅读，觅食，归巢。</li></ul><p><img src="/2017/03/12/2017随记-1200bookshop/img2.jpg" style="width: 30em;" alt="书店夜晚"></p>]]></content>
      
      
      <categories>
          
          <category> 2017随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017随记-海鸥岛</title>
      <link href="/2017/02/12/2017%E9%9A%8F%E8%AE%B0-%E6%B5%B7%E9%B8%A5%E5%B2%9B/"/>
      <url>/2017/02/12/2017%E9%9A%8F%E8%AE%B0-%E6%B5%B7%E9%B8%A5%E5%B2%9B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/02/12/2017随记-海鸥岛/img2.jpg" alt="没有海鸥的海鸥岛"><br><a id="more"></a></p><ul><li>起床，肝阴阳师到10点。</li><li>吃石磨肠粉，到11.30出发，去海鸥岛。</li></ul><hr><ul><li>到了石磅后，等了好久的车，终于等到148B了，车上有三个妹纸目的地是海鸥岛，不过却在同兴村下了。我在江鸥村下，寻找红树林，遇到了一个跟我目的地相同的妹纸，于是便约着一起去海鸥岛。</li><li>一路走，一路聊，她来自湖南，学经济的，刚来广州一个月，做销售管理，校招来这里的，公司在浔峰岗那边，打算辞职回湖南，故临走前到处走走玩玩。</li><li>我们绕着湖骑自行车到五点，坐148回去。在进地铁前，问她回去吃什么，她说公司食堂五点关门，回去只能吃泡面。我说，吃泡面这么恶心？遂邀请之一同吃饭。最后我们在体育西的绿茵阁吃过晚饭，在燕塘分手。我最终也没问她名字，她也没问我名字，吃饭给钱时她要转回我支付宝也被我拒了。</li></ul><hr><ul><li>跟名字都不知道的陌生人过了一天。<br><img src="/2017/02/12/2017随记-海鸥岛/img1.jpg" style="width: 30em;"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2017随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
